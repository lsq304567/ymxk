HTML：
其实学习HTML就是学习它的标签代表什么意思，以及如何使用这些标签将内容组织起来。跟着w3school的HTML部分刷一遍 O'Reilly的《Head First HTML与CSS》
CSS:
核心知识点是：盒模型、相对布局和绝对布局《CSS权威指南》 《高级Web标准解决方案》《CSS揭秘》
其他css书籍真的可以不用再看了，看完《CSS权威指南》你已经就可以把CSS使用的很好了，后面两本权当提高自己水平的读物。
JS:
JavaScript：《JavaScript DOM编程艺术》 《JavaScript高级程序设计》《JavaScript权威指南》 《JavaScript语言精粹》
如果你对JS毫无所知，这里推荐一套JS的学习姿势：先看《javascript高级程序设计》前三章，看完前三章接着看《javascript DOM编程艺术》，建议看两遍这个书，照着书老老实实敲代码，至此，你已经能应付一些常见的页面交互了，后面的两本书就留着以后抽时间慢慢看把。











（三） 一个程序员应该具备的基础知识和概念
1、计算机是有什么组成的，CPU是什么东西，其工作原理是什么。（对于这些以及下面将要提到的概念我不会告诉你什么答案，你可以看相应的教材，关于教材我会在下一部分详述，记住理解最重要！）
2、机器语言和微指令集的概念。
3、程序的概念。
4、汇编语言是低级语言但不是机器语言。
5、高级语言主要有那些？（C，C＋＋，Basic，Pascal，Fortran，C#，Java等等；如果你是中国软件业的英雄，你也写一门语言，最好不用英语） 
6、编译程序和解释程序的概念和其原理。（编译器是高手和专家编写的）
7、HTML、XML等是标识性语言。
8、Prolog是人工智能语言。
9、操作系统OS的概念和原理。（Windows98，Windows2000，Windows NT，UNIX，Linux，等等都是OS，还有一些实时OS，嵌入OS，编这些的绝对是高手）
10、Windows编程说白了就是Windows API的调用。（中国的程序员很多只是会编windows程序，用的是VB，我的建议是这些程序员顶多只是低级编码员，我称其是coder）
11、VC＋＋、VB、BC、BCB、Delphi、VF等都只是编程的工具和环境，不是编程语言。
12、面向结构的设计概念。
13、面向对象的概念。（好好理解，兄弟，这个东西还是很重要的）
14、软件工程的概念和原理。（如果你想当老总就需要好好研究了，系统分析员比编码员要高一个等级，薪水也高哟）
15、数据库的概念。（要熟悉一些著名的数据库系统和语言的名字，如Orcle，SQL，DB2，DyBase等）
16、了解网络概念。
17、了解多媒体概念。
18、熟悉和掌握数据结构和基本算法。
19、是不是要求太高了，别着急慢慢来，进步在不知不觉之中。（一旦开始学习，一个月以后你就会有一个基本的概念；两个月以后你就会感觉自己有了全面的基础知识；当你知道编程序是怎么回事时，说明你已经入门了。也有很多人编了很多年程序还没有入门呢，你不会希望自己步其后尘吧。要有信心和耐心。沉不住气怎么能成大事？！）
（四） 教材推荐
――－推荐的教材主要还是针对概念来的，最好选用名校的教学用书。
1、《计算机组成原理》（熟悉）
2、《数据结构》（掌握）
3、《操作系统》（了解->熟悉）
4、《The C language》（掌握）
5、《编译原理》（了解原理）
6、《汇编语言》（了解）
7、《计算机网络》（了解）
8、《软件工程》（了解）
9、《关系数据库》（熟悉）
10、《The C＋＋Languege 》（掌握）
11、《面向对象设计》（掌握；结合C++学习）
（五）一些经验和体会
1、真正的程序员用C++；（一位专家说的）
2、动手去编程序；
3、动脑去思考；
4、要有良好的编程风格；
5、读书，读好书，尽量读原版书！（我反复强调这一点，读书要有选择，坚持读好书，名家出的经典书，不要浪费实践在一些粗制滥造的书上面；坚持博览群书）
6、有自己的学习计划；
7、总结自己的经验教训；（准备一个笔记本，记录错误和心得）
8、不要怕学新东西；
9、要有软件工程的思想；
10、善于发现问题，然后去寻找答案；
11、向高手请教；（要虚心直到你成为高手）
12、和同行交流；（不善于交流肯定不行）
13、懂得软件的实质，不要被千变万化的表象所迷惑；
14、真正要学习用的是编程语言和方法，不是什么库，什么类，什么工具；（学用那些什么库都比较简单，但光会这些库，我觉得还远远不够）
15、学习wiodows编程主要是学习windows OS和win32 API；
16、有空了解一下嵌入式开发；
17、有空了解一下PDA软件开发；
18、了解一下.NET框架和C#语言，也许它是你新的衣食父母；
19、要有耐心，不要作浮躁的人； 
20、对程序加注释，并保留你的老程序；
21、学到的东西越多，了解的越多，你就越接近专家；
22、有空去逛逛CSDN，那里有你很多知己；
23、要有信心成为一个优秀的程序；
（六）一些好书的推荐
1、《The C Programming language》 （Keinighan & Dennis Ritchie 1988）
2、《The C++ Programming Languague》（Bjarne Stroustrup 1997）
3、《Inside The C++ Object Model》 （lippmans）
4、《Effective C++》 （同上）
5、《More Effective C++》 （同上）

6、《Exceptional c++》未必
7、《C++面向对象高效编程》未必

8、《设计模式》
9、《Thinking In C++》
10、《The Standard C++ Bible》（一般推荐）
11、《The Art of Computer Programming 》
12、《Programming Windows》 （Charles Petzold）
13、《VC++5.0技术内幕》
14、《MFC 深入浅出》
15、《软件需求》
16、《Advanced Windows》
17、《C++ primer》
18、《win32程序员参考手册》
19、《用TCP/IP进行网际互连》
20、《COM 本质论》
（七）学习计划
――－这个学习计划是我个人定的，也共享给大家参考一下，共同进步吧。 
1、《计算机组成原理》
2、《操作系统》
3、《数据结构》
4、《汇编语言》
5、《 C 》
6、《 C++ 》
7、《VC 技术内幕》
8、《Programming Windows》
9、《深入浅出MFC》
10、《Advanced Windows》
11、《Inside The C++ Object Model》
12、《Thinking in C++》
13、《Effective C++》
14、数据库
15、网络
16、嵌入式OS和编程
17、硬件单片机
18、.NET和C#
19、软件工程
20、UNIX和Linux
学术型的视频还是很推荐的，比如斯坦福的机器学习，清华的操作系统、数据结构
《c++primer》《effective c++》《effective stl》《数据结构与算法分析》
《csapp》《深度探索C++对象模型》
《TCP IP详解卷一》《APUE》《UNP卷一》
《Linux多线程服务端编程》
了解actor模式和reactor的异同
《剑指offer》

CSAPP 《深入理解计算机系统》
这是 CMU 的“计算机科学导论”的教材。是计算机系统和操作系统入门。（这门课要求有编程基础）
SICP 《计算机程序的构造和解释》
这是 MIT 的6.001课程的教材。是编程语言入门。（这门课在好几年前就改成Python了）

《Head First HTML5》和《Head First PHP & MySQL》
用Codecademy

《SICP》，大家都说好，虽然我没读过（因为知道这本书的时候已经太晚了，我翻了一下目录就知道不用看了），相比之下我认为第一本加上《Haskell趣学指南》一起看获得的东西不仅涵盖SICP，还要更多。


《算法导论》这是 MIT 的6.006课程的教材。是算法分析入门，适合智商比较高的人当作入门读物，特别是在等以后的前女友迟到的时候。
《Parsing Techniques》，进阶读物，当你背诵完《算法导论》每一个算法/数据结构的伪代码、复杂度和使用的前提条件，但是却找不到东西可以练习，而且又喜欢装逼的话，可以看这本。这本书号称一条公式也没有（后来我发现他一行代码也没有，估计作者认为代码跟公式一样难懂），但是有很多图例，超级入门。把这里面的知识全部实现完，《算法导论》的每一个细节你也同时锻炼了。此书由于（在我发现的时候）全球只卖出100+本，所以你不要指望有任何人会去翻译他。同时作者也已经开放pdf下载了，不算盗版






如何跟老代码友好相处
vczh
vczh
专业造轮子，拉黑抢前排。gaclib.net
?关注他
2,636 人赞了该文章
旅游管O了一天，睡觉前刚好有点时间，就上来写点东西。后面还有将近一个星期的路程。
在Office工作也已经超过两年了。尽ffice是微软C++新标准最有力的推手之一，我在这里面学到的东西其实跟语言倒没什么关系，主要还是跟老代码(legacy code)相关的事情。
@Hush
 曾经安利过我一本《Working Efficiency with Legacy Code》，不过我还没看，你们有兴趣可以去读一读。

面对legacy code的情况有很多，不仅仅在工作中会遇到一些198x年写的代码跟2016年写的代码混在一起的情况，哪怕是开发自己的GacUI也会有。尽管GacUI公开立项是在C++11发布之前不久，但是实际上整份代码是在我读大学的时候造各种轮子的时候，慢慢组合起来的。现在在注释里面还能看到类似Vczh Library ++ 3.0的字样，那1.0是什么呢？

Borland是在我上大一的时候把Delphi卖掉的，我也是差不多在那个时候第一次感觉到了自己学到的东西好像突然就没有价值了，于是趁这个机会全方面转向C++。第一个任务自然就是要把我以前写Delphi的时候积累下来的轮子用C++重写一遍，那就是Vczh Library++ 1.0。++的意思就是这是C++写的，怀念Delphi。后来慢慢的一边修改一遍重构一边删除各种东西，因此我自己所有的C++个人项目都是围绕着这个库来开发的。从这个角度来看，GacUI的一部分代码算起来也有十年之久了，这个年龄其实已经超过了大家工作的时候能遇到的大部分项目的年龄了。所以在这里介绍的经验，对大部分的人都应该是合适的。

Legacy code造成的最大的问题是什么？其实就是最新的best practice和标准，与过去的开发经验的矛盾。这是面对legacy code开发的时候，遇到的的主要矛盾。这个问题在Office尤为明显。GacUI嘛，也只有十几万行。只要我哪天中了彩票，我可以辞职在家里从头优化，花个一年还是能够把所有的东西都改成最好的。至于Office，哪怕你让全球的办公软件开发商停下来等你，好让你把所有的代码都翻新一遍改成最好的，也是一件不可能的事情。

Office客户端的一个版本的代码（不包括分支也不包括历史），拉下来所有的文件就有300多G。这里面有差不多20-30G其实是所有平台的编译器和SDK，还有一些全球语言的字符串和配置，还有一些图标和测试，剩下的占了大部分内容的都是代码。Office现在有很多千人在做，30多年通过不断的收购以及打字，最终创造了这么多代码。平均每个人要负责的代码就有超过30M那么多（是GacUI的十几倍）。要全部翻新一遍，量子计算机应该也普及了。所以首先我们要明白的事情就是，用最新的标准来要求程序员产出的代码是不可能的。哪怕是新的代码，只要这些东西跟古老的部分有一点关系，你做起来就会更加困难。那落实到具体应该怎么做呢？实际上最合适的办法就是，当你在修改哪一个年代的代码的时候，就按照那个时候的要求，也就是整份代码的风格来写。

其次就是重构。前辈们的经验告诉我们，重构最大的好处就是，通过现在多花一点时间，来节省未来无穷多的时间。那节省的时间到底是什么呢？其实就是新的需求跟就的架构的矛盾带来的开发效率的降低。你为了现在的需求做了一个设计，很好的满足了需要，架构弄好了之后业务逻辑写出来特别的快。但是需求总是会变更的，总有一天你的架构就会成为落后的架构，在上面实现新的需求就会变得很困难，开发效率就降低了。在我们总是希望软件的生命无限延续的前提下，我们需要适当地做一些重构，来满足现在或者短期的快速开发业务逻辑的需要。

举个很简单的例子，如果我们在命令行里面打印一个菜单，按下数字键就可以做一些不同的事情，那当软件刚刚诞生，里面的东西还不多的时候，我们会直接的使用if(input == 1) { ... } else ... 的方法来写。后来你加进去的东西越来越多，你会发现if的那些代码就总是重复，所以有一天你改成了switch(input) { case 1: ... break; ...}。再后来，你发现由于业务逻辑的变化，这个菜单开始有增删改的要求，那你总不能每次拿掉一个东西就把所有的case重新修正一遍吧？这个时候就会开始使用函数指针数组，在main函数里面初始化之后，input就可以直接当下标。后来这个软件中遇到了更加复杂的需求，菜单开始不是线性的了，你可能也就即将开始感觉到一个UI库的重要性，慢慢的就引进了各种设计模式。软件的迭代从宏观上来看，道理也是一样的。

但是面对legacy code的重构有其独特的难点。一个持续进化软件的legacy code很legacy，通常也就意味着这个软件也不小，那你重构的时候需要处理的地方就非常多。你这项工作可能要持续半年，在这半年里面你又不能push，因为重构了一半的代码多半是跑不起来的。别人也不可能停下来等你重构，所以会在旧的架构的基础上不断地添加新东西，那么你需要处理的事情就会越来越多，直到爆炸。这也是很多古老的软件无法进行任何重构的重要原因之一。

但是这个问题并不是无法解决的。在Office里面有三种风格的重构。

第一种就是靠一个牛逼的人，就是可以迅速结束战斗，同时一个change上去感染了几千个C++代码文件，上去还能跑。遇到这样的人只能每天路过办公室门口的时候进行膜拜。我就有幸目睹了一个principal的毛子干了这样的事情，因为之前一直都有合作，觉得真是太伟大了。

第二种就是让大家一起来。你开一个branch，把基础的东西弄好，然后让每一个人都在自己的工作之余加入到你的重构工作来，其实也就是把他们自己的组件的代码改成兼容你的新架构的。等到所有的组件都翻新过后，最后让大家一起再解决一遍pull request里面的conflict。

第三种就是，在旧的库的旁边写一个新的库，然后只要你库的对象不是在整个系统里到处传播的，那么你总是可以一个一个文件慢慢地把#include换掉，把代码改成兼容新库的形式。这样在后面修改这个文件的人自然也就被迫使用你的新库了。一直到所有对老库的#include都消失了，把老的删掉，重构工作就完成了。这样做的好处是你的新代码是不断地push给大家的，不会有merge的噩梦出现。

但是重构也不是万能的。因为毕竟一个架构如果没有影响到你的开发效率的话，为什么要去重构他呢？做这个很容易就变成过度设计了。这在GacUI的身上就很明显。大家可能会发现，我在知乎上说C++新标准下面应该如何如何做的时候，GacUI出现的却总是那些过时的方法。其实一个很重要的原因就是，事情还没发展到我非翻新旧代码不可的时候。

举个例子，C++11说你们可以用shared_ptr、weak_ptr和unique_ptr来表达不同对象的生命周期，从而最大程度的避免对裸指针的使用（避免粗心用错）。但是GacUI仍然大量使用Ptr<T>和裸指针。其实原因有三个。

第一个就是，代码是旧的，在这套东西还没反映在标准里面的时候，Ptr<T>已经被广泛使用了。那现在我要不要再添加新功能的时候，使用shared_ptr，让系统里面同时出现两套智能指针呢？这当然是不行的，因为智能指针有自己管理引用计数的方法，不同的智能指针几乎是不可能混用的。

第二个就是，既然如此，为什么我不把Ptr<T>删掉直接全部换成shared_ptr？这就反映了上面粗体的内容。Ptr<T>换成shared_ptr真的就能提高开发效率嘛？如果GacUI是由很多个人写的，那这个很难说，毕竟不是所有人都知道Ptr<T>的各方面细节。但是我作为GacUI的“几乎”唯一的作者，我对代码的所有方面都有无限的了解，我用裸指针也很少犯错误，所以shared_ptr的好处仍然不值得我做一次全文替换。

第三个就是，其实Ptr<T>还有shared_ptr所没有的功能。GacUI的脚本引擎支持脚本创建新的类，这个新类可以继承自若干个C++里面的类，新类还能被反射出来使用。这就在实际上造成了，在内存布局上面，新类其实就是N个对象组成的，N-1个C++里面的类，还有一个脚本创建的模拟的类。那么这几个类的实例其实应该共享同一个引用计数的指针。不然父类实例用了一半，子类实例被早早析构了，这就尴尬了。

大家可以发现，用新的智能指针实现这个东西的方法就是，脚本创建的类去unique_ptr所有的父类，然后dynamic_cast其实就是去获得一个内部用shared_ptr装着子类的、父类接口的shared_ptr或unique_ptr，实现就是把虚函数redirect到父类那里去。当然这样你的父类就要求全部都写成接口（COM就是这么干的）。看起来很别扭是不是？因为C++这一套东西对这个场景其实不能很好的表达。

但是反过来，我可以很轻易地通过修改Ptr<T>、可以被脚本继承的类的基类DescriptableObject，加上通过SFINAE来让Ptr<T>面对普通类型的时候使用普通的实现，来轻松的做到这一点。要换成shared_ptr就要变成另一套做法了，重构难度还是挺大，超过了对以后开发效率的改善。COM的Aggregation是对相同的问题的另一套做法，我不小心重新发明了一次。

类似的内容还有很多，C++11出了for(auto x : xs){ ... }，然而我所有的地方还是用FOREACH(X, x, xs){ ... }宏。C++17即将就要有range了，而我却有老早就为了弥补range不存在，#include <algorithm>里面的东西组合起来又太难而山寨的Linq。C++11有了T&&之后，容器就变得非常好用。但是我自己需要的容器不多，加上这个T&&的支持也不难，所以我最终也没有把自己的类换成STL。给定新标准下一个支持X&&够早的X类，一个返回X类型的属性的setter最好的写法是SetX(X x)，不是X&&x，也不是const X& x，也不是两个都有。但是其实很多地方我也没换。因为这些东西的替换实际上都无法带来什么显著的好处，所以干脆就留着了。

剩下的还有很多琐碎的地方我也就不一一提到了，10年前的一些次要组件现在看起来可能会发现代码里有各种问题，但是反正已经写好了，改得更好用起来也不会更方便，干脆就放着不管了。

GacUI就几乎只有我一个人在写，添加新feature赶紧做完，好腾出手来造新的轮子，才是第一目标。代码是否符合最新的C++规范，那是其次。这放在很多商业软件上也是成立的。我的理由是由于我想造新轮子所以要赶紧把GacUI做完，商业软件为了生存下去给自己员工涨工资要迅速发布和迭代产品，这两个理由其实是等价的。

回到Office里面，其实也会经常遇到类似的问题。三个不同的古老的组件，使用了收购回来的时候内部就已经有的三个字符串类。有一天我要把他们整合到一起，怎么办？其实最经济的方法就是，把他们都严严实实地封装进自己的接口里面，别人不要去碰他们，只有我来碰。那我内部最多也就是多写几个恶心的字符串转换的代码而已。隔绝的好处就是，落后的组件的实现，通过我改头换面之后，对别人的伤害降到了最低。因此我也没有必要去重构他们了。这样就使用最短的时间，在保证质量的前提下，写出了不会降低别人开发效率的代码。

重构是要看成本的。当然反过来，哪怕是一个重构很难，规模很大，但是他创造的效益更大的话，就值得你去说服大老板让你去做。

在讲完了重构之后，剩下的一个大问题就是，那添加新的代码怎么办？其实这也是要按照相同的标准去做的。你添加新的代码，是否会因为旧的架构的影响，让使用你的新代码进行二次开发的人的开发效率被降低？如果你认为答案是“会”，这可能就是一个重构的信号，你要先重构，然后再加新代码。否则，你就按照跟原有的部分兼容的方法去写就好了。当然了，如果情况允许的话，你也可以通过上面讲到的第三种重构的方法，先从你的新代码开始，推广新的架构。等整个系统的每一个角落都被你翻新了之后，旧的架构就删掉了，你就在完成了一次重构的同时，要加的新feature早就上线了，不会影响到release的日期。

总的来说，为什么会有这些准则？其实根本的原因是，修改代码会造成regression，如果你测试的覆盖不够，重构也会引发大量的问题（这就是为什么重构跟测试是相辅相成的，少了一个都不行）。老的代码没有重构的必要就不要重构，你的整体工作量也就大大降低了，同时保证了软件可以被release。

一个刚刚加入工作的程序员，或者是一个学生，可能在遇到类似的问题的时候都比较激进，然后就会被事实教做人。其实这都是因为年轻人眼界不够高，没办法在全局观上看到很多事情背后的cost。所以如果你恰好加入了一个古老的软件的项目组，不要对旧的东西产生抵触，就是一个良好的开始。


























编程指南


作者：二胖
链接：https://zhuanlan.zhihu.com/p/34418394
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

1. 我应该选择什么编程语言

可能困扰编程新手最多的一个问题是【我应该学什么编程语言】或者【我需要学习哪些课程才能做出一个web、一个app】，很多人一直纠结这个问题，陷入了东学一点、西看一点的死循环，到头来啥也没学好，这会很浪费时间。

刚上大一的时候，我也很想知道应该选择什么编程语言。我问了很多人，网上各种查资料，但所能得到的答案都很片面，多数对这个问题答非所问，总是回答说“某某编程语言难”，“某某编程语言性能好”。其实作为初学者，我们对计算机体系都不了解，就不要过多地去纠结性能，或者难易等因素，原因我等下再说。

如果你有明确的方向，那么很好选择。如果你想做算法、机器学习方向，那么python是最好的选择。如果你想做web开发，java、php等都可以。如果想做一些更底层的工作，那么就可以选c。当然这是建立在你有明确方向的基础上。可是，很多人都没怎么接触过计算机行业，特别是和我一样刚入学就被调剂到计算机专业的人。对这些同学来说，各个编程语言就只是个名字，除了叫法不一样，你根本不知道它们有什么差别。所以索性不要纠结了，我替你选一个吧。

如果你是在校大学生，那么你有大把连续的时间，就先学习c，然后再学c++。我个人是学c入门的，也许很多人不理解我为什么推荐学c，因为c和c++都很难、很复杂，看起来并不适合入门。然而正是它们的难和复杂才能让你更好地理解计算机系统【计算机系统不是指操作系统】。学习编程不是学习编程语言，而是学习一个计算机生态，即一个庞大的知识体系。只会编程语言而不理解整个计算机的体系，就像只会写字而写不出好文章。了解c/c++和了解计算机系统是极为贴合的，向下可以帮助你更容易地理解操作系统、编译原理、计算机网络、计算机组成原理，为什么呢？因为较为底层的东西很多都是用c实现的，和系统的贴合度极高，很多教材源码甚至教程，在讲述这些知识的时候都是用c或c++作为媒介。而向上，c++面向对象的机制，也可以做出一些应用，譬如五子棋游戏等，也不会显得那么枯燥。花个小半年时间了解c和c++，之后你就会觉得看书、看资料可以轻松很多。

如果你是一个上班族，但是刚刚学习编程，可能学c和c++对你来说有些复杂和困难，因为学习它们确实是很需要时间。你们不像在校生那样有大把的连续时间，而零碎的时间去学习一个比较复杂的东西效果不见得有那么好，所以可以先学一些【更容易见效】的编程语言，从python入手吧，至少能快速做出一些小应用，不至于丢失了兴趣，但是真的要入门编程又还得看看与计算机系统相关的书籍，这样才能更深层次地去编程，譬如【深入理解计算机系统】这一本书可以读很多遍，这本书把整个计算机系统给串起来了。



2.学习编程，我需要学习哪些课程？

我要学哪些课程？我为什么要学习如高数、离散数学、线性代数、概率论等课程？

这个问题也是之前困扰了我很久的问题。不过我现在想通了，对于【高数、离散、线性代数、概率论】等课程，很好解释，做算法的同学肯定知道为啥要学习这些课程。机器学习中会大量用到上述提到的课程，所以会比较好理解。对在校生而言，学校开设的很多课程我们不知道为什么要学，我们很疑惑，不知道学它有什么用，这个时候我们就会很纠结，还会产生抵触情绪。这很正常，因为我们学习得不够深入，自然不能理解它们的用处。

在我看来，大学本科课程更多的是面向“面”的教学，即什么课程都教给你一些，但是又讲得不那么深入；而工作或者读研，更多的则是面向“点”的学习，用到的知识更专。本科时，学校也不知道你以后是去搞算法、还是搞架构、还是搞服务器开发，甚至去搞硬件，所以学校需要你学很多课程，至少有个了解。对学生来说，一方面可以从中选择自己感兴趣的点；一方面也可以对未来的就业方向有些启发。所以即使像数电、模电等课程，虽然之后可能用不着，但是你也要学，并且会花费大量的时间。虽然你最后不一定去搞硬件，但是这些课程也会让你更容易去理解一些知识，比如cpu中的逻辑器件。

如果你在大一的时候就有一个明确的定位，知道自己今后想从事哪方面的工作，课程与课程之间是可以调一下优先级的。不过像大学物理，这种课程确实是对编程没有帮助，但是像我前面所说的，大学教育更注重广度，大物等课程可能就是为了给你普及生活常识吧。

其实，大学教育的问题是普遍存在的，我认为我们学习一项技能的时候，应该采取的是项目驱动式学习，即需要用到什么东西时不会了再去学，而不是先填鸭式的都填进脑子，并且在学习的过程中我们还不知道它这是干嘛用的，等之后用到了，甚至不记得自己学过，反而查资料才会想起：哦，原来我之前学的xx科目是这个用处啊，可是我当时并没有好好学。很多时候学生时间的浪费可能还是要怪老师、怪学校，他们一开始没给我们做好充分的课程介绍。所以，在经过比较多的编程和项目实践后，我认为一个比较好的学习方式是，改良版的项目驱动学习法。即：

学习一段时间，做个小项目，将做项目遇到的问题记下来，针对性地学习相关知识，然后再实践，再学一段时间理论，让知识成网状发射状地变大。当然，项目驱动式学习有一个弊端，就是每次学习的知识都是项目所需要的，很零碎、不成体系，所以需要改良，即在采取项目驱动学习法的时候每天抽一段时间去完整地读一本书，或者一个相关问题的完整介绍，这样就很容易把一些知识成体系地串起来。这样一段时间下来，慢慢的，你就知道我们为什么要学那么多科目，学这些科目能干什么。

为了表达地更加形象，我就举一个小例子，是我最近遇到的。我本身的工作是做Linux C++的，但不仅限于此。我个人对python、数据分析，以及机器学习等内容比较感兴趣，大家可以看到我最近也在我的专栏发布了很多文章。就从数据获取开始，我讲讲我这两个月做了什么东西。

谈到数据获取，可能最容易想到的是爬虫，爬虫是一个在知乎上被说烂了的话题，所以我不想多说它是什么。很多时候有人觉得爬虫简单，为什么呢，因为有现成的框架，所以获取少量的数据就比较容易。但是当你需要爬取的数据很大的时候（比如我之前抓取了知乎500万用户的数据，在下班的时间、用自己家里普通的pc，计算机性能并不是那么好，比不上服务器，又要在不被封IP的情况下抓到这么大量的数据，然后对数据进行清洗，最后还要可视化展示），使用现成的爬虫框架就并不是那么容易实现了。况且，我需要抓很多数据源，并不是一锤子买卖。所以我选择去开发一个系统，即在现有的框架下进行二次开发，搭建一个属于自己的爬虫系统，并植入一些算法。我在系统中添加了很多中间件，直到现在，它还可以在10分钟内就部署一个能抓取大量数据的爬虫应用。当然，这个过程也遇到了不少麻烦，我就简单讲讲，怎么去攻克一个个问题。

下面先给出一个树形图，从上往下每一个圈都代表了学习过程中遇到的难点，如果你现在看不懂，没关系，我想告诉你的是一种梳理知识的方法：


如上图所示，就是一个项目驱动式学习的例子，我们的目的是为了获取数据，所以选择了爬虫：

爬虫可以理解为一个简单的过程：发送request，获取response，然后提取数据。这个过程会涉及到网络，是发送http还是https请求；目标网站是否需要登录，是post请求还是get请求，从这条线，衍生出了一条对网络进行学习的路径。
获取到网页之后，如果不是结构化的数据，可能返回的是一个html源代码，那么可能就需要了解dom，或者html页面解析的知识，甚至需要了解一下前端开发。
在抓取的过程中，经常会遇到数据中途不能被爬取的情况，一般是IP被封禁了，那么可能又要用上代理，代理是什么呢？http，https代理能不能混用呢？如何构建一个代理池呢？这里又有很多要学习的东西。还有可能遇到的情况是，抓下来的数据是加密的，需要通过js解密，这时候就要了解一下js，如何用爬虫模拟浏览器进行抓取。除此之外，如果抓取的频率不对，很多数据源会给你假数据，这就是一些经验问题了，本文不是技术文，所以就不多讨论。
当解决了上述问题后，我们好像可以拿到一些数据了，但是当数据大起来，问题又复杂了，你可能需要使用分布式抓取了，这时候你可能需要了解一下redis，当request产生的速度大于其消费的速度之后，你的任务队列可能爆炸，所以这里又涉及到算法和数据结构的应用了。
数据量上去之后，把数据写在文件里面是不靠谱的，这时候又涉及到存储了，到底是使用关系型数据库还是非关系型数据库呢，有什么区别呢？存进去的数据怎么去重呢？为什么insert操作越来越卡了呢？电脑怎么越来越热了呢？索引是什么，什么时候该建立索引呢？这里又牵扯到数据库原理相关的知识。
遇到一些比较难处理的网站，比如有验证码识别该怎么办呢？其实对于很多纯数字和字母的验证码都很好解决，自己用深度学习训练即可。在TensorFlow的Demo中就要生成验证码自己训练的教程，然后制定个中间件放在爬虫系统中，这个问题就解决了。可是什么是深度学习呢？这里又引出一条对深度学习进行探索的例子，而我自己也是之前在学校的时候自学了小半年机器学习，有了一定的基础后，才能比较容易地上手TensorFlow框架。再往下就比较深了。
上述六点简单讲了讲项目驱动式学习的介绍，其实，你看到的每一个小圆圈，深挖下去都大有文章。我们现在看到的只是冰山一角，任何一条学习路径学习下去都深无止境，我们不可能完全学会，可是项目驱动式学习最大的好处是让你知道你应该去学习什么，而不是先学一大堆知识，再去做一个项目。严格来说，项目驱动式学习的可视化路径是一张网，而不是一棵树，这里画成树状只是为了便于大家理解。

除了获得数据，还有清洗数据、分析数据，甚至挖掘数据，最后可视化数据并且展示数据，这里我就不一一介绍了。可以参见下面这张图，如果大家想看我做的一些成品，可以看看我的其他文章。


3.学习编程是否需要制定计划？

学习编程是否需要制定计划，该制定什么样的计划呢?

我认为不只是编程需要制定计划，其他任何的学习和工作都需要制定计划。我从13年上大学就开始定期给自己制定计划，这个习惯也一直坚持到了现在，受益匪浅。当然也不只是制定学习计划，还可以列一些自己需要做的其他的事情。我最近在整理笔记的时候也发现了一些之前记录的计划和清单，可以给大家看看。比如下图就是我14年写的笔记，笔记上都留下了最后一次打开的时间。列举了一些自己需要看的文章，因为当时不太懂得规划，所以比较乱。


到了16年的时候，我做计划做得更加有条理了。下图是16年10月30日的计划，那时候我已经大四了，并且已经找到了工作、签了满意的offer，并且没有什么课，按理说可以放松放松了，不过我还是制定了一些学习计划，并且选择在11月去百度实习。从内容上看，主要是学习英语和计算机专业课，因为大一大二的时候我确实不明白为什么要学习专业课，到了大三下想清楚原因以后，我也就一直在重新学习，因为计算机专业课真的很重要！学好了这些课，能让你在日后的学习工作中轻松不少：


除了大四制定的计划外，大二的时候我也制定过较为详细的学习计划（如下图），把需要学习的内容进行了编号，存入表格，这样才能让你过得有条不紊。当然，很难完全按照计划去执行，不过制定相应的计划能让你清楚地知道自己应该干什么。


所以，如果你是在校生，那么好好制定一个计划吧，因为你有大把的时间。当然，如果你已经毕业了，没关系，我现在也在上班，同样也列举了自己最近要学习的内容，如下图（2月27日更新过），包括了短期和长期需要学习的内容：


4.编程是否需要做笔记和写博客？

我觉得，写不写博客无所谓，因为博客是要写出来给大家看的，可能要保证格式美观、语法也要尽量准确，最好比较有文采，我觉得太麻烦也就一直没写。而笔记是必须要做的，并且记笔记是一个长期的过程。在学习的过程中，我们一直都在追求一种最高效的学习方法，比如，同一个班的同学，他用他的学习方法考上了清华，而你用同样的方法就不行，为什么？因为他的方法对他自己而言是定制化的，可能且大概率不适合你，比如他的笔记你不一定能看懂，因为他可能设计了一套属于自己的符号。而就编程而言，很多同学说善用搜索引擎，是对的，可是搜索引擎搜出来的是别人的答案。你照搬过来，也许可以用，但是你没有记住，这些知识并不属于你，之后你可能还会遇到同样的问题，又要再搜索一遍，可能很难找到之前的那个答案了。但是记笔记就不一样，记笔记是定制化的，对你自己定制，你可以用自己最爽的表达方式来描述一个问题，是自己写给自己看的东西，看了几遍之后就能非常迅速和容易地理解。之后遇到相同的问题可以快速地通过找笔记解决。

举个例子，下图是我记录的一些关于gdb【linux下调试c++的工具】的使用的一些笔记。我只记录了我自己最常用的一些内容，也许你看着很乱，但是我就能很容易看懂，这就是我的定制化。


记笔记的习惯一定要坚持，等过个一年或者两年，这就是你巨大的财富，因为那是只有你才能看懂的东西。我已经记录了4年多、1G多的内容，现在的笔记基本已经形成了体系，可以给大家展示其中的一部分。

专业知识相关笔记：


开发相关的笔记：


一些类目：


5.有什么比较好的编程方法？

除了上述分享的一些方法，我认为在同一时间段不要学习太多类别的课程，比如你可以同时学习python和html/css，但是你不要同时学python、操作系统、编译原理、计算机组成、数据结构、网络，我曾经试过，一门课没学一会儿就学下一门，其实上一门根本学不到什么实际的知识。因为记忆知识是符合艾宾浩斯记忆曲线的。对于一门课，特别是很难的专业课，譬如操作系统，你每天看半小时，效果是比较差的，可能你热身就得半小时。所以宁可每天学两门，然后每一门学长一点的时间，比如两小时。【毕竟学校上课，一次课也得两小时】，要避免贪多，一口吃不成个胖子。



6.我需要刷oj么？

我认为刚开始编程的时候还是应该刷的，但是一定要注意，不要被你周围的“X神”给误导了。因为我上大学的时候，身边总是有很多搞计算机竞赛的人，他们之间都互相称对方为“X神”，某某神又使用一个牛逼的算法，将程序时间从1秒降低到了0.999秒。我要劝大家的是，刷题不是为了达到这个目的，不是说非要在竞赛中拿奖，除非你是特别喜欢，否则，没必要去背代码。我们刷题的目的是适应写代码的感觉，在这个过程中你会遇到编译错误，你会慢慢去记住一些语法、关键字，并理解一些概念，还可以自己去使用它，比如实现数据结构。慢慢的你就会变得有经验，知道一些错误产生的原因。我也是慢慢这样过来的，我现在在工作和下班以后写代码时，基本都不用IDE了，比如写c++，要么vim，要么就是sublime，而调试用的是我前面提到的工具gdb。即，有一个文本编辑器就能写代码，脱离了IDE的束缚。在写oj之后一段时间，在比较熟练了之后，就可以不去刷题了，可以去譬如github这样的网站上找点项目来看，然后自己跟着写一下，编程能力慢慢就提升了。就计算机专业来说，很多同学在大一上完编程课之后，就很少写代码了，这样是很不好的。刷题除了可以锻炼编程能力，对于找工作前突击也很有作用。比如，我之前投递过华为公司的研发岗位，校招的时候有笔试题。我就在16年国庆的时候刷了一下华为的oj，我记得笔试是600分的总分，过100就给面试机会，而我很轻松的就拿了500分，而当时也就刷了20多道华为的题。


7.看书还是看视频？

网上有不少人鄙视看视频学习的同学，我不知道为什么，因为我认为看视频是一个很好的学习方式。不过我们得明白看书和看视频分别有什么优缺点。

其实我是很建议看视频入门的，因为目前网上的应用型【非学术型：比如清华大学的操作系统，非常难】的视频都是很简单的，很多是面向初学者的，视频能用较短的时间告诉你你现在所学的技术可以干什么，可能需要先修哪些知识，可以帮助我们搭建一个项目驱动式学习的网络。可是视频也有个缺点：就是知识非常的杂，很不系统。虽然现在很多教学网站都提供了学习路径，但是这些路径中的视频很多时候都不是同一个老师录制的，只是按照知识的依赖关系排的顺序，所以，如果想通过视频去系统地学习一门知识，是比较困难的。【当然，一些学术型的视频还是很推荐的，比如斯坦福的机器学习，清华的操作系统、数据结构等课程，能坚持看完，绝对受益匪浅】。而应用型的，比如web开发等知识，还是得看书。书籍等特点就是系统化，由浅入深，你可以定制化地看自己薄弱的章节。所以一个比较好的学习方式是：

看视频入门，看书进阶。



8.多久能学会编程？

其实这个问题是没有答案的，如果只是想做出一个小应用，2个月足矣，而就我个人而言，我认为学习编程不是学习一种编程语言，而是学习一个生态，一个计算机系统，所以无止境。



9.我应该选择什么资料，看什么书？

其实这个问题也是很多编程新手容易困惑的问题。网络上拥有我们一辈子都看不完的教程和资料，所以现在应该不会存在找不着视频教程、找不着书看的问题。而问题就是我们不知道看什么视频、看什么书。从开始学编程到现在，我也买了上百本书，而真正适合自己的好书并不多。而视频教程的问题就更严重了，东看一点、西看一点，知识很难组织成网络。所以学习编程的过程中，我们遇到的最大的问题是：当我们遇到问题的时候，在大量资料面前，我们不知道选择什么资料去学习。即使我们使用项目驱动式学习的方法找到了我们的方向，但是同一个路径下，也有很多资料。前文列举的项目驱动式学习的图中，我们是自上而下的去发现问题，然后再解决问题。如果能有人帮我们组织好学习路径，然后自下而上地去学习，那么效率可能会提高很多。

不过不用担心，我已经尽我所能，将我看过或者我认为好的课程和书本资料给串了串，整理好上传了，所有学习资料均免费，无任何收费课程。




























垃圾项目维护经验

作者：血狼
链接：https://www.zhihu.com/question/49279694/answer/139414734
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

我分享一下我的经验吧。
几年前，从事LTE 4G核心网的开发，手上的代码是2G时代的代码。自己是项目经理，手下六个人，两个毕业一年，四个应届生，代码量是40W行C++。这40W+行代码，有部分能用，有部分不能用，还有新的需求加上去，一年内左右要差不多能够商用。经过10个月时间，我们七个人满足了新需求，加了几个功能，代码也削减到30W行。
我面临的问题，旧代码太多，年代可以追溯到90年年代。风格比较乱，可以看出有多少人写过，加功能也很难，而下面都是经验很浅，甚至没有经验的员工，不光要加新功能，还得重构，还得培训他们，还得审核他们的代码质量。唯一比较欣慰的就是有一个比较旧的自动化测试框架。
当时我的做法是这样：
1. 第一步，打log。让应届生给代码打log，写完之后，提交到crucible上进行review。从这上面给他们改进建议，让他们熟悉打log的规范，怎么打出有意义的log。这作为第一步的好处是，它不会改变代码逻辑，也不会影响代码，可以放心交给应届生来做，也可以让他们知道这些功能大概是什么。
2. 第二步，拆函数。把一些大函数拆成小函数。让他们在管的模块方面，把那些大的函数拆成小函数。每次提交前都要review，并把自动化测试的结果贴上去。在这上面，教他们一个函数只做一件事情的准则。而且由于之前已经打log了，所以他们也很容易定位问题。在熟悉log的基本上，可以让他们学会用gdb调试
3.第三步，清除和系统API功能相关的代码。由于第二步完成时，他们负责的模块一般只有小函数了，而且他们对流程也懂了，这时候让他们学一些系统API，平时在代码review时根据代码逻辑给出建议，让他们看一下哪些系统API。这样他们就知道怎么改了，也尝到使用系统API的甜头，就会主动去学系统API。
4.第四步，清除和系统通用工具相关的代码。在第三步完成之后，他们负责的模块已经比较好了，但代码量有时候还是比较多，而这时，他们大概已经比较清楚自己模块的功能。这时候就要开始进行会议讨论和分享。由于代码比较旧，有些功能现在可以通过一些系统工具实现了。就和他们提一下，让他们直接调用工具。基本上，这一步对代码削减就非常大了。
5.第五步，画图。在第四步时，已经让他们开始接触UML。到第五步，就让他们把自己模块的流程用UML画出来，然后评审，看哪些类是不合理。基本上在这一步，就能够发现很多没用代码，然后就整改。

1~5这几步，review和自动化测试都要抓紧。特别review，要重视编程技巧和知识面的提示



























轮子哥

作者：vczh
链接：https://www.zhihu.com/question/40875856/answer/88698096
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

《The Implementation of Functional Programming Language》，比什么私房菜要精彩、易懂和有用一百倍。
《Code》，这知识的程度只能是初中课外读物，虽然很多程序员都很吹捧，没看过的还是要看看。
《SICP》，大家都说好，虽然我没读过（因为知道这本书的时候已经太晚了，我翻了一下目录就知道不用看了），相比之下我认为第一本加上《Haskell趣学指南》一起看获得的东西不仅涵盖SICP，还要更多。
《算法导论》，适合智商比较高的人当作入门读物，特别是在等以后的前女友迟到的时候。

《Parsing Techniques》，进阶读物，当你背诵完《算法导论》每一个算法/数据结构的伪代码、复杂度和使用的前提条件，但是却找不到东西可以练习，而且又喜欢装逼的话，可以看这本。这本书号称一条公式也没有（后来我发现他一行代码也没有，估计作者认为代码跟公式一样难懂），但是有很多图例，超级入门。把这里面的知识全部实现完，《算法导论》的每一个细节你也同时锻炼了。此书由于（在我发现的时候）全球只卖出100+本，所以你不要指望有任何人会去翻译他。同时作者也已经开放pdf下载了，不算盗版。

要成为一个好的程序员，虽然要懂得，但是不要太去在意，更不要把别人发明出来的一些“巧合”视为自己知识的重要部分：譬如说一些叫creat的命令，如何挽救滚坏的系统，或者iPhone的正确大小写等等。






























计算机普及介绍

作者：王晋东不在家
链接：https://zhuanlan.zhihu.com/p/25863794
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

1 平台

1.1 桌面平台：[1.1.1 Linux,1.1.2 Windows,1.1.2.1 .NET平台,1.1.2.2 非.NET平台,1.1.3 Mac]

1.2 移动平台：[1.2.1 安卓Android,1.2.2 iOS,1.2.3 Windows Phone]

1.3 Web平台：[1.3.1 前端,1.3.2 后端]

2 语言

[2.1 C, 2.2 C++, 2.3 C#, 2.4 Java, 2.5 HTML, 2.6 PHP, 2.7 Python, 2.8 ASP.NET, 2.9 其他]

3 工具

[3.1 Visual Studio, 3.2 Eclipse, 3.3 Intellij IDEA, 3.4 Android Studio, 3.5 XCode, 3.6 Pycharm]

4 辅助

[4.1 数据库, 4.2 Github, 4.3 MOOC]


1.平台
1.1 桌面平台

桌面平台以操作系统来分类，分为Linux、Windows和Mac三个平台。

1.1.1 Linux

Linux是著名的黑客Linus在大学开发的开源操作系统，建立在早期的Unix内核基础上。由于它优良的特性及开源的管理方式，吸引了全球大批的开发者使用。Linux一般是用于服务器，因为它作为一个操作系统来说本身极其优秀，适合在后台作为服务器系统持续稳定地运行。 Linux上的编程是比较基础的，考察你对命令的掌握情况，不过对于新手的话，还是有一定难度的。虽然号称掌握了Linux就说明是个大牛，但是至少这种言论是片面的。不过学习Linux确实能提高对计算机的理解能力，这方面比较好的书有一个叫[《鸟哥的Linux私房菜》](http://vbird.dic.ksu.edu.tw)，专门为学Linux写的好多书，业界评价很高。

1.1.2 Windows

Windows是使用最为广泛的操作系统，粗略分类也可以为分个人用户版本（专业版，基本版，家庭版等）和服务器版本（Windows Server）。不过由于Win10的推出，Windows现在实行全平台统一内核的方式管理，又新增了嵌入式版本的Windows。 Windows上的编程是最基本的，因为绝大多数人都在用Windows。从QQ到英雄联盟，从快播到书店管理系统，从ATM到银行交易，基本都是在用Windows（当然，很大一部分后台都是Linux。Windows和Linux是最重要的操作系统）。Windows下有很多的编程框架，大致可以分为两种：一种是微软出品的（限于Windows就是微软的）以.NET为代表的编程框架，另一种是其他第三方的平台。

1.1.2.1 .NET平台

以前的.NET只能运行在装有特定版本的Windows操作系统上。.NET伴随着Windows的更新也一直从1.0升级到如今的4.5.以.NET为母体，如今微软将.NET开源了，苹果和linux都可以用了。通过mono，可以在各个操作系统上调用.NET。不过，真正拿.NET主力开发的，恐怕大多数还是windows吧。有MFC(C++，非常古老)、WinForm(C#，主流)、WPF(C#)等编程框架。

- MFC：很古老的一种编程框架，用C++写的，有控件，有事件，有服务，很完备。缺点就是东西太古老，不好用，现在各高校仍然有课程在用（比如图像处理等），但是做这东西事倍功半，不推荐；

- WinForm：非常主流的编程框架，很多软件都是用这个框架做的。用C#作为编程语言，运行很稳定，好上手，开发成本低。

- WPF：微软新推出的编程架构，界面很绚丽，用XAML+C#作为开发语言，优秀的MVC架构，是未来的趋势。可惜发布时伴随着Vista系统的失利，加上其本身庞大的资源消耗，所以基本上没有多少人在用。不过它的思想是先进的，一路走来赶上win8和win10（商店应用）都是在用的。

1.1.2.2 非.NET平台

非.NET平台的框架一般都可以跨平台使用。

- Qt：诺基亚出品的编程框架，用C++开发。有自己的界面库，支持跨平台。在前些年很火，不过现在不流行了。

- Java平台：Java本身是个语言，但是基于Java有很多开源的框架和平台，如Swing等，都提供自己的控件。不过运行效率太低，因为Java本身就是个虚拟机。目前随着硬件平台效率的提高，已经不是问题。绝大多数服务器后台都运行的是java。

- 还有其他的平台，在Windows上使用率基本很少。

1.1.3 Mac

Mac是苹果专用操作系统，苹果系统很大一部分软件都是用Mac下的软件开发工具做的。Mac下的开发框架叫Cocoa，iPhone下的叫CocoaTouch（多了个touch）。当然，Mac下的软件也可以用上面的跨平台的框架来开发。这方面不做过多介绍。

1.2 移动平台

现在最火的就是移动平台了，这一点毋庸置疑。

1.2.1 安卓Android

安卓是一个开源的操作系统，在2008年首次推出，之后由Google收购，到现在是最火的操作系统。Android的内核是基于Linux的，由于其开源的特性，所以很好定制，使得Android在短短几年内迅速占据移动操作系统的三分之二。 Android开发是基于Android提供的SDK（软件开发包）进行的。主要的开发语言是Java（用来写后台逻辑）和XML（用来写界面）。 Android开发有一些书，这方面比较有代表性的是[《疯狂Android讲义》](疯狂Android讲义_百度百科). 早期（2013年前）Android的开发环境是Eclipse，配合Android的SDK、模拟器等，后来Google推出了整套的Android Studio进行安卓开发，效率非常高，现在基本都在采用Android Studio进行开发。

- [视频教程](安卓Android开发_安卓Android开发视频教程从入门到精通 - 麦子学院)

1.2.2 iOS

iOS是苹果iPhone以及iPad上的操作系统，只能在苹果机开发，只能用在苹果产品上。iOS是一个及其优秀的移动操作系统，安卓在发展的早起，很多都是借鉴了iOS的开发经验做的（当然，后来就互相抄袭了）。iOS开发使用苹果出品的XCode软件进行，这个软件还可以用来开发Mac下的软件。XCode是一整套的开发工具的集合，可以设计界面、进行调试、上传到应用商店等。iOS开发使用Objective-C编程语言和Swift编程语言，后者是苹果在2013年6月推出的新一代编程语言，集合了当下所有语言的优良特性，大有取代Objective-C的意思。所以Swift一直很火。这方面的教程有：

- [斯坦福大学公开课iOS开发](斯坦福大学公开课：iOS 8开发)

- iOS开发指南等。

1.2.3 Windows Phone

Windows Phone是微软出品的手机操作系统，现在已升级到了Windows Mobile 10.它的开发环境是Visual Studio，用C#进行开发，基本就是windows下开发软件（WPF）的模型是一致的。虽然我在大学做的最多的就是WP（因为上手快，微软的教程给力），但是它的市场占有率多年来一直升不上去。希望得益于Windows10的爆发，能给点力。这方面不给教程了。

1.3 Web平台

Web平台的编程基本是基于服务器的编程。这方面分为网页（前端）和服务（后端）。

1.3.1 前端

前端就是我们所看到的网页。比如[百度](百度一下，你就知道)的首页很朴素，[QQ浏览器](QQ浏览器9官方网站 - 浏览器_浏览器下载_微信电脑版)的首页就很酷炫，等等。这些是用什么实现的？ 实现语言会在后面再介绍。概括来说

- html是所有网页语言的鼻祖，网页都得用它；

- CSS就是一个样式选择器，那些字体、颜色等都是用的CSS来控制的；

- javascript是网页脚本（它可和java没有半点关系），是用来写简单的后台逻辑交互和前端界面交互的；

- html5是最新的html的版本，支持众多的界面特性。QQ浏览器的首页就是用html5做的。

1.3.2 后端

后端是用户看不到的，小到注册一个用户，大到处理几十万的数据，都是后端来做。这方面典型的开发语言是C++、Java、php和python、ASP等。 后端是基于服务器进行的开发。基本上在软件工程中处于很顶级的地位。这方面用Java开发是业界很流行的，因为Java没有C++那么难写，本身又有很多框架，比如Spring等，非常适合写后台的数据交互。

2.语言

计算机编程语言有几百种，小到智能手机，大到服务器集群，都运行着各种各样的编程语言写的程序。没有哪一种程序就比另一种高贵，都各司其职，完成我们交给他们的任务。

计算机专业的学生一般学习编程都是从C或者C++开始的。这两种语言在大多数高级语言中出现较早，影响力也很大。对于计算机专业，当然要学好这两种语言，才能为以后学习其他语言打下基础。

对于非计算机专业或者以前从没接触过编程的同学来说，不建议上手就学C和C++，因为它们偏难，而且并不是必须的。对于这些背景的同学，十分建议学Python。因为Python首先是跨平台，然后，没有特别复杂的语法（至少完成日常使用不需要）,最重要的是，有各种各样的包能支持你做各种各样的事情！

2.1 C

C是基础性语言。它不是面向对象的，是面向过程的语言。C诞生于1972年，其优良的特性很高的效率使它长期占据编程语言排行榜第一名。C可被广泛用于桌面、服务器、嵌入式开发中。

- [C程序设计视频教程](C程序设计案例教程（2015秋季）-学堂在线慕课(MOOC)平台)

2.2 C++

C++可以看作是对C的扩展，增加了面向对象的机制。什么是面向对象？简单来说就是，所有的要操作的物体都是对象，比如一个人是一个对象，一条狗也是一个对象。接着就可以在对象上定义操作，比如人走路是一个函数，人吃饭也是一个函数。这样设计的好处就是可以封装起来多次使用，也可以进行继承。保留总体的相似性，又不失个体的个性。比如张三和李四都是继承人这个类，但是张三吃饭要3分钟，李四就要10分钟，这就是个性。面向对象设计的思想可以在[这里](什么是面向对象编程思想？ - Java - 知乎)找到进一步的阐述，这基本是所有现代主流语言的基础。会面向对象，所有的语言学起来特别快。 C++可以被广泛用于桌面端、服务器和嵌入式的编程，使用程度非常广泛，但是由于它的语法很难（主要是指针操作）、没有现成的SDK进行封装，所以并不是很适合用来写移动端的应用。 可以认为，C++什么都能干，它太基础了，效率是高级语言中最高的，但是术业有专攻，它并不是都适合写各个平台的应用。

- [C++程序设计视频教程](C++ Programming | C++程序设计)

2.3 C#

C#是微软是2000年推出的在.NET平台上的编程语言，没有指针，集合了大多数面向对象语言的精髓，好学好用，效率也不低，是主流的windows桌面应用和部分windows服务器后台的编程语言。

- [C#视频教程](C#编程-学堂在线慕课(MOOC)平台)

2.4 Java

Java和C#类似，差不多简单。但是Java是跨平台的，可以写桌面、移动（安卓）和后台服务器，用处非常广泛，框架也最多。

- [Java视频教程](学堂在线-最大的中文慕课(MOOC)平台)

2.5 html

html和javascript、css等都是开发网页前端界面显示的语言，是很轻量级的。

- [html等教程](Codecademy - learn to code, interactively, for free)

2.6 php

php是用来开发服务器后端的语言，非常好学好用，语法很简单。

- [php教程](PHP 教程)

2.7 python

Python是一种脚本语言，执行效率很低，但是语法异常简单，c++写几十行的东西，它几行就可以搞定。Python理论上可以用在任何地方，但是基本上常用于后台服务器和一部分科学研究。作为脚本语言，Python是优秀的。

- [python教程](Codecademy - learn to code, interactively, for free)

- 推荐的一个教程：Python 3教程发布

2.8 http://ASP.NET

http://ASP.NEThttp://ASP.NET是微软出的写服务器后端与部分前端的框架。用C#和html编程。

- [视频教程](ASP.NET基础实例教程-我要自学网)

2.9 其他

其他语言还有几十种，但是都不是很常用。这是不再介绍。 学会面向对象编程思想，走遍天下都不怕。

3.工具

3.1 Visual Studio

微软出品的宇宙最强编程工具，没有之一。 VS可以被广泛用于桌面、服务器和移动端的编程，最新的VS也可以用来做安卓和iOS，其性能之彪悍功能之强大是宇宙第一。写C、C++、C#的天然平台，也可以用来写Python、html等。

- [VS的官网](Visual Studio Home)

3.2 Eclipse

Eclipse是免费开源的软件。它是一个软件平台，配合丰富的插件，可以用来写Java、php、C++、Python等，用来写桌面、服务器应用。

- [Eclipse官网](Eclipse - The Eclipse Foundation open source community website.)

3.3 intellji IDEA

Intellij IDEA是捷克Jetbrains公司出品的收费的编程软件。是Eclipse的替代品。可以把它叫做java界的Visual studio。用来开发基于Java的任何应用。Android Studio就是基于这个软件的框架进行开发的。

- [intellij IDEA官网](JetBrains: Development Tools for Professionals and Teams)

3.4 Android Studio

开发安卓的集成工具。

- [网站](http://www.baidu.com/link?url=ckxMsBEZ42QFFLmh0KtPkZLHHcFMaVnxPwfDvUdFFNsyo1RtqvnyaodTIqqw9Z5z&wd=&eqid=fed82086000f227b000000035646be0f)

3.5 XCode

XCode是用来开发iOS和Mac下的软件的，也就是说它只能运行在苹果电脑上。XCode可以编写的语言主要有C/C++，Objective-C以及swift等。其他XCode个人感觉并不是太优秀，有很多不如人意的地方，不过没办法，你想做苹果的东西只能用这个。JetBrains公司出了一个Mac下写苹果软件的IDE叫做AppCode，我也用过，体验还可以。不过话说回来，有官方的东西就有官方的支持，用第三方的难免会出现不必要的问题，最多也就当个备用吧。

3.6 PyCharm

PyCharm也是JetBrains公司出的专门用来写Python的IDE。它基本可以说是Python界的Visual Studio，想要的功能基本都有。更新也很频繁，目前我一直在用它。

4.辅助

4.1 数据库

数据库是存储数据的媒介，所有后台数据交互的都必须有数据库参与。目前最常用的数据库有Oracle、SQL Server、MySQL、MongoDB等。数据库独立于编程语言，由特定的SQL语法进行支持。

4.2 Github

[Github](Build software better, together)是世界上最大的开源软件管理平台。本文就托管在github上。世界各地的程序员把他们写的各种类型各种语言的代码托管在github上实现共享，有利于软件行业的发展。git代码管理平台是现在最火的版本控制工具。 iOS、安卓等有很多有名的项目都是托管在github上的。

4.3 MOOC

这个主要是网络公开课。现在最火的受教育形式。 近几年，MOOC越来越火，课程的数量和质量都不断发展，给了我们足不出户就能领略世界大师风采的绝佳机会。本文有很多链接都是公开课的。推荐的不错的有：

- [网易公开课](网易公开课)，资源比较多，各个领域都有，里面有计算机板块，中国外国都有。上面说的MIT的算法，我们都是在上面学的，老师讲的特别好。另外它还有不断更新的TED视频，很值得一看。

- [coursera](Coursera | Online Courses From Top Universities. Join for Free)，斯坦福机器学习大牛Andrew Ng联合成立的，上面都是外国大牛校的视频。我研究生课程里的机器学习就是学的这上面的，不错。

- [果壳MOOC学院](MOOC学院（慕课）| 发现全球在线好课)，它只是一个公开课搜索中心，帮助你链接到各个mooc课程。

- [学堂在线](学堂在线-最大的中文慕课(MOOC)平台)，清华主导的，网站做的不错，课程质量很高，这个是要着重推荐的，我也是最近才发现，上面的计算机和数值方面课程不错。

- [codecademy](Codecademy - learn to code, interactively, for free)，这不是公开课网站，是一个手把手教你学习web语言的。这里有Ruby，python，html等热门web语言，而且教程设计丰富而有趣，感觉是学前端最好的地方了。




















自学编程告诫


作者：Blake Jy
链接：https://www.zhihu.com/question/45216002/answer/108923212
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

12点前睡，保证至少7小时睡眠。

拒绝拖延症，今天事今天毕。

不要以理想化的时间估算任务(其中包含了很多隐藏前提)。

深入思考一件事之前先确认自己对这件事或者事物的熟悉程度。

尽可能穷尽自己的已知和未知，循序渐进地完善已知和学习未知。

不要放大了事件或者事物的优势，而看不到其中实现的难点。

框架的好处在于不让用户写出烂的代码，提高了方便性之外限制了用户的代码结构。

不一定每件事每个人都要分高低，还可以看左右。

浅尝辄止是可怕的。

越是紧急的情况下越要冷静，提问自己如何做才能解决这问题？将步骤思考清楚。

技能的反面是解决问题。

怎么提高技能？通过不断地练习，把低层次的问题都解决了，变成不用经过大脑的自动操作。

你只是一个普通人，我们绝大多数都是普通人。

要想得到某样东西，最可靠的办法先让自己配得上它。

不理解循序渐进的重要性，但理解一步登天是不现实的，而一步登天的反面就是循序渐进。

负责，提供各种选择，不要找蹩脚的借口。

不要容忍破窗户，熵增效应会促生软件腐烂。

Remember the big picture.过于集中的注意力，忘了世界的其余部分，要持续不断地观察周围发生的事情，而不只是你自己在做的事情。

读书要配置，学习要配置，吃饭也要配置。

人的时间资源有限，读书要读好书(主要看作者为什么写这本书，用了多大力气写这本书)。

利他即利己。

决心，朋友，计划，执行力。

决定凡人命运的根本差别:人的自身，人所拥有的身外之物，人向其他人所显示的样子。

按合约设计。

crash early，断言用在不可能发生的case。

百折不挠，短期来被看做傻瓜又如何，习惯有人会批评你。

要做就要做到最好的。

站在巨人的肩膀上做创新。

懂产品，懂商业，懂生态ownership，把公司的事业当成自己的事业，own everything。

一技之长(栈内技术，栈外技术，工程经验，带人做事，业界发声)；独立做事(独立coding，独立带新人，独立带团队，独立做业务，独立能生存)；拥有事业(企业使命，商业模型，凝聚人才，整合资源等)。

遇到问题深挖；多思考其他方案；多用google；

学会精力管理。

2017-9-19 此后会更新一些高质量的博客。

---------------------------------------------------------------------------------------------------------------------

大家的支持就是动力,2017-7-26 更新了一些学习资源

收藏比赞多系列~

-------------------------------------- 2017-3-5 update -------------------------------------------------------

unknown unknown,关于从本质上提升自己的能力,可以看一下cat chen的回答,里面推荐的《高效能人士的7个习惯》很赞

大四学生，想通过两到三年的积累去 Google 工作，应如何准备？



当看到上面的回答后,怎样培养自己的能力？除了多思考资源、流程、优先级和构建自己的知识脉络外,还要多造轮子,拆轮子，多对比

什么才算是真正的编程能力？ - 刘贺的回答 - 知乎



在拆轮子，造轮子的时候,不免得要阅读别人的源码，什么才是正确的阅读源码的姿势?

带着自己对这个轮子的假想,有目的性地阅读

程序员阅读源码是一种什么心态？源码对编程意义何在？如何才能更好阅读代码？ - 冯东的回答 - 知乎



我们少不了要学习多门语言，或工作需要,或个人进修，我们怎样快速上手一门编程语言?

孟岩:快速掌握一个语言最常用的50%



少不了更新一些资源

前端的奇舞周刊: 奇舞周刊

OpenDigg - 挖掘优质开源项目库

IBM developerWorks : 技术主题

《技术之瞳-阿里巴巴技术笔试心得》 http://product.dangdang.com/24057987.html

----------------------------------------------------------------------------------------------------------------------



一、各大名校的公开课

Coursera: https://www.coursera.org/
网易云课堂大学计算机课程: 大学计算机专业
学堂在线计算机课程: 学堂在线-最大的中文慕课(MOOC)平台
哈佛大学公开课-计算机科学cs50: 哈佛大学公开课：计算机科学cs50_全20集
麻省理工学院公开课-计算机科学及编程导论: 麻省理工学院公开课：计算机科学及编程导论
很多名校的公开课,我就不一一列举了
二、学完上面的基础,想学PHP,JAVA,C++等?

IT学习资源网站

慕课网: http://www.imooc.com
实验楼: http://www.shiyanlou.com
掘金: http://gold.xitu.io/explore/all
StackOverFlow Documentation: https://stackoverflow.com/documentation
众成翻译: http://zcfy.cc/
牛客网: 牛客网-专业IT笔试面试备考平台,最全C++JAVA前端求职题库,全面提升IT编程能力
学习路线和方法(安利一波萧大的指南)

编程入门指南: 编程入门指南 v1.4 - 萧井陌的专栏 - 知乎专栏
在线练题 ~new

hackerrank: www.hackerrank.com
PKU OJ: http://poj.org/
leetcode: https://leetcode.com/
lintcode: http://www.lintcode.com
牛客网: https://www.nowcoder.com
微信公众号/订阅号(这个是一有零碎时间就可以看的)

前端早读课: FeZaoDuKe
奇舞周刊
W3cplus: w3cplus_12
新智元: AI_era
想学前端或者MEAN全栈套路的可以去看一下FCC(安利一波FCC,着实不错)

FreeCodeCamp: Learn to Code and Help Nonprofits
FreeCodeCamp中文: Learn to Code and Help Nonprofits


三、自学的心得



1、一定要把基础打好,也就是我上面提到的大学公开课,尽管我在一些免费的IT学习社区学得前端或者PHP比较深,也是要回过头来打好基础,因为深入到底层还得是数据结构,网络,操作系统那些



2、学习过程中注意总结,具体可以去看一下费曼技巧:号称终极快速学习法的费曼技巧，究竟是什么样的学习方法？ - 吴笛(pimgeek) 的回答



3、视频教程可以让你快速掌握知识,但深入的话还得看书和做项目



4、可以尝试看英文文档和网站,例如W3C的文档,StackOverFlow,Quora等



5、身心要健康,因为身体是一切革命的资本啊!



6、切忌浮躁



7、给答主点个赞,从此编程路上无BUG,哈哈



8、复杂系统总是源于简单系统的演化,不用考虑太长远,合适现有业务就好,之后再拓展



9、虽然说给帅答主点个赞,无bug,但是bug总是难免的,要耐心去解决,最后总结出错的原因,坚持下来就有快速排错的能力了



10、在没有头绪的情况下,可以把问题阐述一遍给同事,朋友或家人,很多时候会灵光一闪



11、计算机是门应用型为主的学科,以项目为驱动,不断地编码与总结,从此踏上幸福快乐地生活~



12、学而不思则罔,思而不学则殆



13、博学、审问、慎思、明辨、笃行


























别人学习过程


作者：origin
链接：https://www.zhihu.com/question/26421707/answer/53879709
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

比较仔细的学习了《c++primer》，并对每个习题都自己写代码实现了一遍，包括稍微复杂一点的例子。
认真读完了《effective c++》，《effective stl》。
比较仔细的学完了《数据结构与算法分析》，并把其中的每种数据结构和算法都用c++实现了一遍。包括各种线性表，树（二叉树、AVL树、RB树的各种操作），图（BFS、DFS、prim、kruskal、djkstra、floyd、拓扑排序、关键路径等）查找算法，排序算法。
2-3个月认真学完《csapp》并做完书上的课后习题（由于时间的关系，没有在做家庭作业），顺带学习了一些gcc的嵌入汇编的用法。
读完了《深度探索C++对象模型》，对象C++底层实现机制有了一定的了解。
读完了《TCP IP详解卷一》
读了《APUE》的大部分内容以及《UNP卷一》有关TCP/UDP的部分，略过了SCTP的部分。
研究学习 @陈硕的muduo网络库源码，受益良多，在期间发现过其中的一两个小问题，提了几个pull request，研究完了muduo源码后又看了其相关的书《Linux多线程服务端编程 (豆瓣)》
学习了云风的skynet网络库的小部分源码，主要为了了解actor模式和reactor的异同。
学习了google test框架的部分源码，弄懂了内部的的运行原理。
刷《剑指offer》的所有习题。
刷leetcode，代码在liyuan989/leetcode · GitHub，由于时间的关系大约刷了130道就开始找工作了。

关于练手项目，写了简易STL，C++协程库，以及一些http server，rpc之类的。

关于找工作

由于基本都是同学朋友内推，不存在简历被HR筛掉了。

其实自己都惊讶在找工作的时候有些异常顺利，因为面试官问的问题很少有答不上来的。绝大多数问题个人感觉不难，大多都是问的一些比较基础、底层的东西，比如互斥锁底层是怎么实现的？如何用C语言实现C++的异常，说说基本思路这样的问题。然后就是根据简历上写的东西来问。

另外一个要说的就是纸上手写算法题了，手写代码和机器上写代码的感觉不一样，我个人是没事自己在纸上写写一些基本的算法来熟悉，比如快排、堆排序之类的。

然后面试要问的算法题一般都不难，多数都是翻转链表，判断链表是否有环，回文数，找出链表倒数第k个数这样的题目。

很少遇到问二叉树的问题，没有遇到过问图的相关问题。唯一碰到一个动态规划的问题，就是最典型的最长公共子序列问题，难点的就是百度第一面最后问了一个leetcode上hard难度的原题，总的来说刷一些题还是很有必要的。

























编程经典书疑惑

作者：孙天齐
链接：https://www.zhihu.com/question/26157282/answer/32455092
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

我想写小说，大师给我推荐三本经典，我应该按什么顺序学？学了这些，我能写出什么？

不用觉得滑稽，初学者被高大上的书目击倒是正常的，这三本书也确实都是入门经典。但是我们要先搞明白，它们入的是什么门。

CSAPP 《深入理解计算机系统》
这是 CMU 的“计算机科学导论”的教材。是计算机系统和操作系统入门。（这门课要求有编程基础）

SICP 《计算机程序的构造和解释》
这是 MIT 的6.001课程的教材。是编程语言入门。（这门课在好几年前就改成Python了）

CLRS 《算法导论》
这是 MIT 的6.006课程的教材。是算法分析入门。

那么操作系统、编程语言、算法分析又属于什么呢？我们系统地看看，计算机科学到底是干什么的。CS大体可以分成这么几个大领域：硬件、系统、软件、网络、计算理论、计算方法。

硬件 —— 数字电路、集成电路、存储器、各种硬件设计和验证方法等。
系统 —— 计算机架构（指令集、串/并行、网格、云端之类）、嵌入式、实时系统等。
软件 —— 操作系统、虚拟机、编程语言、软件设计/开发/验证的工具和方法论等。
网络 —— 计算机网络的架构、协议、组件、路径算法、性能分析等。
计算理论 —— 可计算性、形式语言和自动机、密码、逻辑、算法分析等。
计算方法 —— 数值计算、符号计算、并行计算、计算机图形学、人工智能、机器学习等。

你可以按这个提纲，逐个了解一下CS是干什么的。但现在可以先看着这些词，大概感受一下。我们再说那三本书：计算机系统属于系统领域，操作系统和编程语言是软件领域中的小领域，而算法分析是计算理论中的小领域，这是那三本书在计算机科学中的位置。它们作为所谓“经典”，入的就是这几个门。现在你知道这几本书是干什么的了，那么你的问题来了：做网站、做APP又属于这里面的哪个位置？

答案是，哪个也不属于。你看整个计算机科学，研究的都是非常底层或基础的东西，与你说的“现实中的产品开发”，基本上是没有关系的。即使有些名称看着和开发有关，其实也不是一回事。比如这里所说的“编程语言”，就好比语言学，是研究各种语言结构的，而不是教你用语言写作的。你要认识到这一点，这不是教材好坏的问题，而是分工不同。就像天文学不是教你制造望远镜的，机械动力学不是教你开挖掘机的。

那么问题又来了，你现在就想学习做网站、做APP，这是什么？怎么学？哪家强？

实际上，国内大学极少有独立的CS专业，都是加个“与技术”，全称叫“计算机科学与技术”。顾名思义，这就包括计算机科学、计算机技术两部分。你想学的这些，就属于那个“与技术”。你想学的是技术方向，别人推荐的却是科学方向的经典，这个就是你困惑的根本原因。

说到这里，我想题主应该已经理解了：计算机科学是干什么的，那三本书是干什么的，以及为什么学完了还是做不出来网站和APP。接下来，我想你会问这两个问题：

1、如果我想搞技术，那么学习科学部分还有没有必要？

我的观点是，这不是有没有必要的问题。这两者之间的区别，是追求的目标不同：科学追求尽量深入，探索原理；而技术追求尽量封装，提高效率。各种高级技术都是力求隐藏细节，以提高效率。而你选择学习内容的标准，就看它能否显著提高你的生产力。有些技术高度依赖底层细节或原理，造成了效率瓶颈，就应该学。但具体到Web、APP开发，最能提高你生产力的，就是那些前/后端框架和脚本，学完了你马上就能做产品，而不是《计算机程序的构造和解释》什么的。当然，上边有些朋友告诉你，你要学挖掘机，一定要先学机械动力学，否则你就没有内功，永远不可能成为挖掘机高手，机械动力学才是真正的知识，只是现在社会太浮躁，没人愿意花时间学。然而，我并没否认机械动力学的价值，它能让你把挖掘机分析得头头是道，甚至设计制造挖掘机。但是，如果你的目标是开挖掘机，那你就不该这样入门，因为这是两回事。说了这么多，希望你明白了。

2、我现在应该如何提高技术水平？

学技术的关键思路是两点：一个是模仿，一个是边实践边学。比如说学挖掘机，首先你要知道基本操作，然后看别人是怎么开的，最后自己上去开。遇到问题，比如跑偏了，你研究一下，挖掘无力，你再研究一下，弄明白了就继续开。具体到你说的做网站为例，首先你可以看看《Head First HTML5》和《Head First PHP & MySQL》，或者用Codecademy，学会基本操作。然后找一些作品，比如WordPress，和它的一些经典模板，去看别人是怎么做的。然后，你就可以自己设计一个小网站，尝试把它做出来。不用等什么都学会了再开始做。做的过程中，你遇到什么障碍，再有针对性地去学习和解决。这种边实践边学习的模式，才是学技术的正确思路，这跟搞理论研究的思路是不一样的。



























MySQL数据库？

作者：姜健
链接：https://www.zhihu.com/question/34840297/answer/67536521
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

本人是个活生生的例子，大学学的仪器仪表专业，毕业前第一份实习工作是电路板测试。由于项目中接触到了数据库的东西，纯粹当高级点的excel表格用的。
当时有点兴趣，没参加过培训，0基础自学mysql和linux，现任国内某公有云mysql &&mongodb dba。
对于非计算机出身的我，大学只会hello word和跑马灯，期间过程确实非常曲折，分享下我的自学过程：

1、 自己在windows和linux上安装了mysql，自学linux的基础知识，学习mysql的最基础的知识，即怎么写sql，存储过程，表的设计等，从0到熟悉大概花了3个月 ，推荐《mysql入门很简单》。

2、系统地较为深入地学习mysql的sql优化，备份和恢复，参数优化，架构优化，硬件层面的优化，高可用方案，复制技术等等，这段时间你不一定能实际接触到这些，就像我当初那样，肯定没什么公司招一个小白。
我选择自己看书，推荐《高性能mysql》，里面所有的章节都需要看一遍，以现在的水平肯定看不懂，但需要知道大概怎么回事，为后续的找mysql初级dba的工作打一个铺垫，这个过程大概也需要3个月。

3、 纸上得来终觉浅，完成以上两步，我开始准备找一份mysql相关的工作，而不是天天用着excel表格做着select * from table_sb这样的工作。
当然我这么猥琐的人肯定不会裸辞，该画的电路板也一样画，业余时间开始投初级mysql dba的工作，并且不间断地学习，网上各种找mysql面试的相关题目（实际上我当时完全没有任何实战经验），陆续收到一些面试，凭借之前自学的mysql知识，开始胡乱吹牛逼，先混进去再说。
你不做mysql实际相关的工作，永远也不知道自己之前认知的db知识有多幼稚。
友情提示一点，一般公司都没有专职dba的，所以面试的时候一定要自信，其实你学了这么多，虽然毫无实战经验，理论知识很大概率比面试你的人牛逼，所以各种吹，我就这样真正进入初级dba的圈子（由于这时对linux还处于cd ls的水平，所以之前也根本没做过运维），这个边工作边找工作的过程又持续了2个月。

4、真正进入互联网，接触生产环境后，这是我进步最大的时候。
第一步需要将之前所学真正地应用起来，并且应用的过程中，再回头看之前的书籍，这时候需要真正去理解，而不是似是而非，一知半解。
这时再推荐《高性能mysql 第三版》，全本再看一遍，这时需要全部看懂，另外还有《mysql技术内幕：innodb存储引擎》等等。
总之这段时间就需要开始关注mysql一些细节了，比如db故障处理，高可用，负载均衡等等的具体实现了。
另外，linux的知识同步也要深入去学习，至少会写shell脚本，常见的linux知识等，我在这花了1年多；
5、 dba的工作一般是非常轻闲的，毕竟不是大公司，技术能力有限，该学的也学得差不多了，接触不到海量数据，高并发等比较锻炼人的场合，于是我又准备跳了。
于是来了公有云，现在每天运维万多个db实例，平均每天处理5+个紧急db故障，几乎mysql会遇到的问题，感觉都遇到了，能感觉到技术实力和经验也在每天都在积累，在进步。
但是感觉还是欠缺了很多，下一步就看你选择了，是再去研究源代码，底层原理的东西多点，还是数据库运维和应用多一点，就比如业界姜承尧，何登成与叶金荣的区别。
由于我的历史原因，对c++等几乎不懂，平时也用不到，所以看代码等事实际太累，于是我再去学mongodb，接了公司mongodb运维的活，算是在广度上的一个扩展，万一哪天mysql不行了呢

6、 总之，对于db小白来说，最重要的一点就是，学习的过程不能断。

PS 上面的方法比较野路子，适合没什么基础的童鞋，如果本来就是DBA，比如从oracle转到mysql，那么建议直接看mysql官方文档，而官方文档是db达到一定水平后必看，出问题时必查的权威文档























程序员应该懂得算法

作者：SimonS
链接：https://www.zhihu.com/question/23148377/answer/36824071
来源：知乎
著作权归作者所有，转载请联系作者获得授权。

初期（校赛及省赛水题难度）:

一.基本算法:

枚举. (poj1753,poj2965)
贪心(poj1328,poj2109,poj2586)
递归和分治法.
递推.
构造法.(poj3295)
模拟法.(poj1068,poj2632,poj1573,poj2993,poj2996)
二.图算法:

图的深度优先遍历和广度优先遍历.
最短路径算法(dijkstra,bellman-ford,floyd,heap+dijkstra) (poj1860,poj3259,poj1062,poj2253,poj1125,poj2240)
最小生成树算法(prim,kruskal) (poj1789,poj2485,poj1258,poj3026)
拓扑排序 (poj1094)
二分图的最大匹配 (匈牙利算法) (poj3041,poj3020)
最大流的增广路算法(KM算法). (poj1459,poj3436)
三.数据结构.

串 (poj1035,poj3080,poj1936)
排序(快排、归并排(与逆序数有关)、堆排) (poj2388,poj2299)
简单并查集的应用.
哈希表和二分查找等高效查找法(数的Hash,串的Hash) (poj3349,poj3274,POJ2151,poj1840,poj2002,poj2503)
哈夫曼树(poj3253)
堆
trie树(静态建树、动态建树) (poj2513)
四.简单搜索

深度优先搜索 (poj2488,poj3083,poj3009,poj1321,poj2251)
广度优先搜索(poj3278,poj1426,poj3126,poj3087.poj3414)
简单搜索技巧和剪枝(poj2531,poj1416,poj2676,1129)
五.动态规划

背包问题. (poj1837,poj1276)
型如下表的简单DP(可参考lrj的书 page149): E[j]=opt{D+w(i,j)} (poj3267,poj1836,poj1260,poj2533) E[i,j]=opt{D[i-1,j]+xi,D[i,j-1]+yj,D[i-1][j-1]+zij} (最长公共子序列) (poj3176,poj1080,poj1159) C[i,j]=w[i,j]+opt{C[i,k-1]+C[k,j]}.(最优二分检索树问题)
六.数学

组合数学: 1.加法原理和乘法原理. 2.排列组合. 3.递推关系. (POJ3252,poj1850,poj1019,poj1942)
数论. 1.素数与整除问题 2.进制位. 3.同余模运算. (poj2635, poj3292,poj1845,poj2115)
计算方法. 1.二分法求解单调函数相关知识.(poj3273,poj3258,poj1905,poj3122)
七.计算几何学.

几何公式.
叉积和点积的运用(如线段相交的判定,点到线段的距离等). (poj2031,poj1039)
多边型的简单算法(求面积)和相关判定(点在多边型内,多边型是否相交) (poj1408,poj1584)
凸包. (poj2187,poj1113)
中级（校赛压轴及省赛中等难度）: 一.基本算法:

C++的标准模版库的应用. (poj3096,poj3007)
较为复杂的模拟题的训练(poj3393,poj1472,poj3371,poj1027,poj2706)
二.图算法:

差分约束系统的建立和求解. (poj1201,poj2983)
最小费用最大流(poj2516,poj2516,poj2195)
双连通分量(poj2942)
强连通分支及其缩点.(poj2186)
图的割边和割点(poj3352)
最小割模型、网络流规约(poj3308)
三.数据结构.

线段树. (poj2528,poj2828,poj2777,poj2886,poj2750)
静态二叉检索树. (poj2482,poj2352)
树状树组(poj1195,poj3321)
RMQ. (poj3264,poj3368)
并查集的高级应用. (poj1703,2492)
KMP算法. (poj1961,poj2406)
四.搜索

最优化剪枝和可行性剪枝
搜索的技巧和优化 (poj3411,poj1724)
记忆化搜索(poj3373,poj1691)

五.动态规划

较为复杂的动态规划(如动态规划解特别的旅行商TSP问题等) (poj1191,poj1054,poj3280,poj2029,poj2948,poj1925,poj3034)
记录状态的动态规划. (POJ3254,poj2411,poj1185)
树型动态规划(poj2057,poj1947,poj2486,poj3140)
六.数学

组合数学: 1.容斥原理. 2.抽屉原理. 3.置换群与Polya定理(poj1286,poj2409,poj3270,poj1026). 4.递推关系和母函数.
数学. 1.高斯消元法(poj2947,poj1487, poj2065,poj1166,poj1222) 2.概率问题. (poj3071,poj3440) 3.GCD、扩展的欧几里德(中国剩余定理) (poj3101)
计算方法. 1.0/1分数规划. (poj2976) 2.三分法求解单峰(单谷)的极值. 3.矩阵法(poj3150,poj3422,poj3070) 4.迭代逼近(poj3301)
随机化算法(poj3318,poj2454)
杂题(poj1870,poj3296,poj3286,poj1095)
七.计算几何学.

坐标离散化.
扫描线算法(例如求矩形的面积和周长并,常和线段树或堆一起使用) (poj1765,poj1177,poj1151,poj3277,poj2280,poj3004)
多边形的内核(半平面交)(poj3130,poj3335)
几何工具的综合应用.(poj1819,poj1066,poj2043,poj3227,poj2165,poj3429)
高级（regional中等难度）: 一.基本算法要求:

代码快速写成,精简但不失风格
(poj2525,poj1684,poj1421,poj1048,poj2050,poj3306)
保证正确性和高效性. poj3434
二.图算法:

度限制最小生成树和第K最短路. (poj1639)
最短路,最小生成树,二分图,最大流问题的相关理论(主要是模型建立和求解) (poj3155, poj2112,poj1966,poj3281,poj1087,poj2289,poj3216,poj2446
最优比率生成树. (poj2728)
最小树形图(poj3164)
次小生成树.
无向图、有向图的最小环
三.数据结构.

trie图的建立和应用. (poj2778)
LCA和RMQ问题(LCA(最近公共祖先问题) 有离线算法(并查集+dfs) 和 在线算法(RMQ+dfs)).(poj1330)
双端队列和它的应用(维护一个单调的队列,常常在动态规划中起到优化状态转移的目的). (poj2823)
左偏树(可合并堆).
后缀树(非常有用的数据结构,也是赛区考题的热点).(poj3415,poj3294)
四.搜索

较麻烦的搜索题目训练(poj1069,poj3322,poj1475,poj1924,poj2049,poj3426)
广搜的状态优化:利用M进制数存储状态、转化为串用hash表判重、按位压缩存储状态、双向广搜、A*算法. (poj1768,poj1184,poj1872,poj1324,poj2046,poj1482)
深搜的优化:尽量用位运算、一定要加剪枝、函数参数尽可能少、层数不易过大、可以考虑双向搜索或者是轮换搜索、IDA*算法. (poj3131,poj2870,poj2286)
五.动态规划

需要用数据结构优化的动态规划.(poj2754,poj3378,poj3017)
四边形不等式理论.
较难的状态DP(poj3133)
六.数学

组合数学. 1.MoBius反演(poj2888,poj2154) 2.偏序关系理论.
博奕论. 1.极大极小过程(poj3317,poj1085) 2.Nim问题.
七.计算几何学.

半平面求交(poj3384,poj2540)
可视图的建立(poj2966)
点集最小圆覆盖.
对踵点(poj2079)
八.综合题. (poj3109,poj1478,poj1462,poj2729,poj2048,poj3336,poj3315,poj2148,poj1263)


=====================================================================


扯点建议：

如果你不是要死磕acm搞出成绩来的话，多放点心思在数据结构上对以后的帮助会比较大，比如字符串相关的字典树、哈希、自动机、后缀树等等，而对脑力要求较高的比如博弈论和各种花式动态规划（树型DP、集合DP、插头DP等等）就不用太关心了。


btw这些算法和数据结构如果能精通的话，对你以后做数据挖掘和机器学习是有极大帮助的

























1、 程序员意味着要编程序。（如果你仅仅想得到一份高薪水的工作，喝喝咖啡就等老板发薪水，我奉劝你还是另找一份更合适的工作，譬如练摊，真的，兄弟，这份工作不适合你）
2、你是学文的还是学理的，编程序也许需要浪漫，但更需要逻辑和严谨。（说坦白点就是，在你没有找到乐趣以前，它很枯燥）
3、你有对新技术追求的热情吗？你有刨根问底的探索精神吗？（热情绝对是最重要的！你仔细思考一下自己的性格适合当程序员吗？）
4、当程序员决不是什么好差事，时刻需要学习，需要思考。（直到你成为那个可以引导别人去学习和思考的人，你才可以偷偷的嘿嘿笑，又一群傻蛋）
5、程序员的未来很迷茫。（但我认为关键看你自己！我希望你是一个有追求的人，不仅仅是混碗饭吃。因为真正的乐趣在于创造；如果你能改变软件业的历史，那才是英雄；不想成为Bill Gates，不想成为Dennis Ritchie和 Bjarne Stroustrup，我会说你没有追求。有个关于程序员未来的笑话，也许你还没听过，你该听一听，摘抄如下：
一个程序员对自己的未来很迷茫，于是去问上帝。
“万能的上帝呀，请你告诉我，我的未来会怎样？”
上帝说“我的孩子，你去问Lippman，他现在领导的程序员的队伍可能是地球上最大的”
于是他去问Lippman。
Lippman说“程序员的未来就是驾驭程序员”
这个程序员对这个未来不满意，于是他又去问上帝。
“万能的上帝呀，请你告诉我，我的未来会怎样？”
上帝说“我的孩子，你去问Gates，他现在所拥有的财产可能是地球上最多的”
于是他去问Gates。
Gates说“程序员的未来就是榨取程序员”
这个程序员对这个未来不满意，于是他又去问上帝。
“万能的上帝呀，请你告诉我，我的未来会怎样？”
上帝说“我的孩子，你去问侯捷，他写的计算机书的读者可能是地球上最多的”
于是他去问侯捷。
侯捷说“程序员的未来就是诱惑程序员”
这个程序员对这个未来不满意，于是他又去问上帝。
“万能的上帝呀，请你告诉我，我的未来会怎样？”
上帝摇摇头“唉，我的孩子，你还是别当程序员了”）
6、当程序员还是很有乐趣的。（当你学到新知识时，当你有新的思想见解时，当你有新的产品问世时，和知己探讨你的成果时…我问你，觉得这些是乐趣吗？）
7、当程序员不易也不难。（世间事有难易乎？为之…；不为…。你有决心和信心吗？）
8、你真的要当程序员？是你自己的想法？
9、你舍得花钱买书吗？（读好书绝对是学习编程的最佳捷径。你一定会说，现在电脑书籍真他XX的贵，没法子，谁让知识和技术在人家的脑袋，在人家的书里呢；等你写书时可以把价格定低一点，记着还有好多没钱但想买书的兄弟很困难呀。要舍得买书，买好书，不好的的书不如不读，其害大于其益，关于买什么书，你可以问高手或看候捷的书评；准备一个小本子记录你想买的书的名字，逛书店时看看，如果好就买下，记住要读，别光买不看。） 10、我告诉你，程序就是：任何有目的的、预想好的动作序列，它是一种软件。
11、编程序就是编写程序。
12、你想好了吗？（如果你想好了还是决定要当程序员，可以继续往下读；否则，你可以继续寻找别的出路了。）
（三） 一个程序员应该具备的基础知识和概念
1、计算机是有什么组成的，CPU是什么东西，其工作原理是什么。（对于这些以及下面将要提到的概念我不会告诉你什么答案，你可以看相应的教材，关于教材我会在下一部分详述，记住理解最重要！）
2、机器语言和微指令集的概念。
3、程序的概念。
4、汇编语言是低级语言但不是机器语言。
5、高级语言主要有那些？（C，C＋＋，Basic，Pascal，Fortran，C#，Java等等；如果你是中国软件业的英雄，你也写一门语言，最好不用英语） 6、编译程序和解释程序的概念和其原理。（编译器是高手和专家编写的）
7、HTML、XML等是标识性语言。
8、Prolog是人工智能语言。
9、操作系统OS的概念和原理。（Windows98，Windows2000，Windows NT，UNIX，Linux，等等都是OS，还有一些实时OS，嵌入OS，编这些的绝对是高手）
10、Windows编程说白了就是Windows API的调用。（中国的程序员很多只是会编windows程序，用的是VB，我的建议是这些程序员顶多只是低级编码员，我称其是coder）
11、VC＋＋、VB、BC、BCB、Delphi、VF等都只是编程的工具和环境，不是编程语言。
12、面向结构的设计概念。
13、面向对象的概念。（好好理解，兄弟，这个东西还是很重要的）
14、软件工程的概念和原理。（如果你想当老总就需要好好研究了，系统分析员比编码员要高一个等级，薪水也高哟）
15、数据库的概念。（要熟悉一些著名的数据库系统和语言的名字，如Orcle，SQL，DB2，DyBase等）
16、了解网络概念。
17、了解多媒体概念。
18、熟悉和掌握数据结构和基本算法。
19、是不是要求太高了，别着急慢慢来，进步在不知不觉之中。（一旦开始学习，一个月以后你就会有一个基本的概念；两个月以后你就会感觉自己有了全面的基础知识；当你知道编程序是怎么回事时，说明你已经入门了。也有很多人编了很多年程序还没有入门呢，你不会希望自己步其后尘吧。要有信心和耐心。沉不住气怎么能成大事？！）
（四） 教材推荐
――－推荐的教材主要还是针对概念来的，最好选用名校的教学用书。
1、《计算机组成原理》（熟悉）
2、《数据结构》（掌握）
3、《操作系统》（了解->熟悉）
4、《The C language》（掌握）
5、《编译原理》（了解原理）
6、《汇编语言》（了解）
7、《计算机网络》（了解）
8、《软件工程》（了解）
9、《关系数据库》（熟悉）
10、《The C＋＋Languege 》（掌握）
11、《面向对象设计》（掌握；结合C++学习）
（五）一些经验和体会
1、真正的程序员用C++；（一位专家说的）
2、动手去编程序；
3、动脑去思考；
4、要有良好的编程风格；
5、读书，读好书，尽量读原版书！（我反复强调这一点，读书要有选择，坚持读好书，名家出的经典书，不要浪费实践在一些粗制滥造的书上面；坚持博览群书）
6、有自己的学习计划；
7、总结自己的经验教训；（准备一个笔记本，记录错误和心得）
8、不要怕学新东西；
9、要有软件工程的思想；
10、善于发现问题，然后去寻找答案；
11、向高手请教；（要虚心直到你成为高手）
12、和同行交流；（不善于交流肯定不行）
13、懂得软件的实质，不要被千变万化的表象所迷惑；
14、真正要学习用的是编程语言和方法，不是什么库，什么类，什么工具；（学用那些什么库都比较简单，但光会这些库，我觉得还远远不够）
15、学习wiodows编程主要是学习windows OS和win32 API；
16、有空了解一下嵌入式开发；
17、有空了解一下PDA软件开发；
18、了解一下.NET框架和C#语言，也许它是你新的衣食父母；
19、要有耐心，不要作浮躁的人； 20、对程序加注释，并保留你的老程序；
21、学到的东西越多，了解的越多，你就越接近专家；
22、有空去逛逛CSDN，那里有你很多知己；
23、要有信心成为一个优秀的程序；
（六）一些好书的推荐
1、《The C Programming language》 （Keinighan & Dennis Ritchie 1988）
2、《The C++ Programming Languague》（Bjarne Stroustrup 1997）
3、《Inside The C++ Object Model》 （lippmans）
4、《Effective C++》 （同上）
5、《More Effective C++》 （同上）
6、《Exceptional c++》
7、《C++面向对象高效编程》
8、《设计模式》
9、《Thinking In C++》
10、《The Standard C++ Bible》（一般推荐）
11、《The Art of Computer Programming 》
12、《Programming Windows》 （Charles Petzold）
13、《VC++5.0技术内幕》
14、《MFC 深入浅出》
15、《软件需求》
16、《Advanced Windows》
17、《C++ primer》
18、《win32程序员参考手册》
19、《用TCP/IP进行网际互连》
20、《COM 本质论》
（七）学习计划
――－这个学习计划是我个人定的，也共享给大家参考一下，共同进步吧。 1、《计算机组成原理》
2、《操作系统》
3、《数据结构》
4、《汇编语言》
5、《 C 》
6、《 C++ 》
7、《VC 技术内幕》
8、《Programming Windows》
9、《深入浅出MFC》
10、《Advanced Windows》
11、《Inside The C++ Object Model》
12、《Thinking in C++》
13、《Effective C++》
14、数据库
15、网络
16、嵌入式OS和编程
17、硬件单片机
18、.NET和C#
19、软件工程
20、UNIX和Linux







































四 技术比较

没有最好的框架，只有最合适的应用场景。

在前端的开发工作开始之前，我们应该就不同的前端技术进行分析比较，从而更好、更流畅地进行编程开发。

4.1 JSP 与 jQuery

就技术而言，JSP 与 jQuery 是天南地北的。但是，jsliang个人觉得可以就内嵌 HTML 的形式与前后端分离的形式，对 JSP 与 jQuery 进行简要比较。这里的比较，仅仅因为工作中同时有涉及 JSP 与 jQuery，如有不实，望海纳指正。

关于 JSP 与 jQuery 的学习记录：

    Java Server Pages
    jQuery

何为 JSP？

JSP 全称 Java Server Page，是 Java 企业应用的一种动态技术。Java 和 JSP 是运行在服务器端的，也就是说他两运行的结果生成 HTML，HTML 是静态页面，而 JSP 是动态页面。

何为 jQuery？

jQuery 是一个轻量级的 Java 库。jQuery 能够使用户的 HTML 页面 和 JS 内容分离，也就是说，jQuery 的使用，更有利于 HTML、CSS、Java 三者的分离，使得前端代码得到更好的维护。

现在就相同功能进行 JSP 与 jQuery 代码比较：

<ul> <c:forEach items="${list}"> <li>${user.userName}</li> </c:forEach></ul>

<!-- HTML 内容填充 -->< src="https://cdn.bootcss.com/jquery/3.3.1/jquery.js"></><> $(function() { // 通过 ajax 从 Java 接口获取数据 var data; $.ajax({ // ...请求地址、请求头及传参等 success: function(res){ data = res.data; // 拼接字符串，并渲染页面 var html = ''; $.each(data, function(index, item) { var html='<li>'+ item.userName + '</li>'; html += html; }) html = '<ul>'+ html + '</ul>'; } }) })</>

咋看之下，你会觉得：“啊，JSP 那么简单，用 JSP 好啊！”

是的，JSP 几行代码就能解决 jQuery 十几行代码才能解决的事，而且运行速度也快过 jQuery，为啥不一直用它呢？

就项目发展而言。公司初创的时候，项目初期结构不繁杂的情况下，使用 JSP 无可厚非，因为它快、省事，而且还能节省人力（前后端让一个 Java 写就可以搞定了）。

但是，在项目越来越繁杂、庞大的情况下，一个 Java 已经维护不过来了，企业必须不停地增加 Java 开发人手，而 Java 人员也深陷技术债中……

然而，就好比喜欢锻炼的不全都喜欢跑步一样，并不是所有操作数据的 Java 都喜欢写页面的，这时候就凸显了几个问题：

    项目越来越大，模块越来越多，需要投入的人手也越来越多，这时候需要分模块分人手地去维护。而且这些 Java 开发人员必须喜欢操作数据也喜欢编写页面，要不然企业将面临员工频繁流动的困扰。
    用户开始对界面操作提更高的要求，需要增加更多的 Java 互动和特效，无形中增加 Java 开发人员的工作量。
    当有员工辞职后，下一名员工接手熟悉项目的时间将逐渐增加，由 1 天增长为 1 周甚至 1 个月。因为他不仅要熟悉数据的操作部分，更需要去维护 Java 的页面互动。而这段时间，辞职员工的工作将施压到其他 Java 开发人员身上。

综上，这时候企业不得不考虑了：能不能帮 Java 开发人员减轻负担，更好地维护发展项目。

以此同时，Java 经过时间的沉淀，越发凸显了它的强大。所以，在诸多因素之下，就有了前后端的分离：

后端人员提供接口，前端人员使用 jQuery 中封装好的 Ajax 调取接口获取数据，渲染到页面上。

4.2 jQuery 与 Vue

在上面的 JSP 与 jQuery 的比较中，我们会发现一个问题，就是 jQuery 在数据操作上，它需要操作的步骤太多了。而且，频繁地操作 DOM。在数据量比较大的情况下，还会造成页面卡慢。

而这时候，就有了 MVVM 等 MV* 概念的提出：

    何为 MVVM 模式？

        Model：提供/保存数据。
        View：视图。
        View-Model：简化的 Controller，唯一的作用就是为 View 提供处理好的数据，不含其它逻辑。

简单来说，就是 MV* 模式，将对数据的操作提升上去了。在 Vue、React、Angular 等 MV* 框架中，可以通过对数据的操作，从而完成对页面数据的渲染。这里我们挑选简单、快速、紧凑而强大的 Vue，与 jQuery 进行比较。

    index.html - jQuery

<!DOCTYPE html><html lang="en"><head> <meta charset="UTF-8"> <meta name="viewport"content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"> <meta http-equiv="X-UA-Compatible"content="ie=edge"> <title>jQuery 代码演示</title></head><body> <div id="app"> <ul id="list"> <li>第1条数据</li> <li>第2条数据</li> </ul> <button id="add">添加数据</button> </div> < src="https://cdn.bootcss.com/jquery/3.2.1/jquery.min.js"></> <> $(document).ready(function() { var i = 2; $('#add').click(function() { i++; //通过 DOM 操作在最后一个li元素后手动添加一个标签 $("#list").children("li").last().append("<li>第"+ i + "条数据</li>"); }); }); </></body></html>

    index.html - Vue

<!DOCTYPE html><html lang="en"><head> <meta charset="UTF-8"> <meta name="viewport"content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no"> <meta http-equiv="X-UA-Compatible"content="ie=edge"> <title>Vue 代码演示</title></head><body> <div id="app"> <ul> <!--根据数组数据自动渲染页面--> <li v-for="item in message">{{item}}</li> </ul> <button @click="add">添加数据</button> </div> < src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></> <> new Vue({ el: "#app", data: { message: ["第1条数据", "第2条数据"], i: 2 }, methods:{ //向数组添加一条数据即可 add:function(){ this.i++; this.message.push("第"+ this.i + "条数据"); } } }) </></body></html>

上面的例子，对这两者进行了简单的比较与区分。虽然只是一个简单的说明，但是在实际中，Vue 能解决的问题远比上面的要多的多，复杂的多。

但是，对 jQuery 与 Vue 进行比较，是推崇 Vue，建议全面废弃 jQuery 吗？并不是。

    Vue 适用的场景：复杂数据操作的后台页面，表单填写页面。
    jQuery 适用的场景：比如说一些 HTML5 的动画页面，一些需要 Java 来操作页面样式的页面。

正应了那句话：“没有最好的框架，只有更适合的应用”。

我们应该根据项目的需求，对技术进行不同的选取。就好比在公众号的 H5 页面上，jsliang就很喜欢用 jQuery 进行操作，因为它简单粗暴好操作，在动画效果的编写上也不错；而在使用 Echarts 进行报表演示的开发中，我更喜欢使用 Vue，因为它能很简易地对后端传回的大量数据进行操作。

4.3 Vue 与 小程序

开篇点题；深入学习过 Vue 开发的，那么在微信小程序、React、Angular 等框架的开发上也不会太差。

为什么这么说呢？因为它们都是基于 MV* 模式的一些现代前端框架。拿其中的 Vue 与 微信小程序 进行一些简单区别：

    生命周期/钩子函数不同，微信小程序的钩子函数要简单地多。
    请求数据方面，Vue 会在 created 或者 mounted 中请求数据，而微信小程序会在 和 onSow 中请求数据。
    等等……

往往很多时候，我们会觉得它们是有很多地方是相同的。

所以，对于 Vue、React、Angular、微信小程序等 MV* 模式的前端框架，如果非得进行区分比较的话，我们应该就框架的使用场景、团队技术能力、框架优劣势、生态系统等方面去分析它们，并区分它们的适用场景：

    Vue：简单易学，灵活轻便。相对于 React 和 Angular 来说，它的学习成本低，适合快速上手，且学习曲线比较平缓。
    React：灵活性很高，生态圈强大。相对于 Vue 来说，React 在数据操作方面更灵动；相对于 Angular 来说，它的学习成本更低。
    Angular：完整的框架体系。相对于 React 和 Vue，它是一个成熟完善的框架。
    微信小程序：简单轻便。相对于 Vue 来说，它更加便捷了，而且微信小程序有上传的代码大小限制，使得微信小程序是真的 “小”。而且微信小程序结合微信，提供了很多 API 供开发人员使用。

因此，前端团队在项目开发前，可以就项目涉及领域进行探讨：

    假如你想快速开发一个成本低的小应用，可以考虑 Vue。
    假如你想开发一个大型应用，可以考虑 Angular。
    假如你想开发一个跨平台应用，可以考虑 React。

事无绝对，这里仅为本人观点，实际技术选用应结合团队意见，从而找到最适合该项目的技术。

    就 jsliang本人的开发体验来说：2018 年 4 月份的毕业设计使用了 Vue 进行开发，然后相隔半年进行了微信小程序开发，发觉小程序开发比起 Vue 而言是更轻松便捷的，因为它封装了很多 API 供开发人员使用，并且它有专门的提 Bug 社区。

五 思考总结

没有最好的框架，只有最合适的应用场景。

希望小伙伴们在面临不同的项目时，可以选择到最合适的框架，从而减少开发工作量，降低开发难度。

最后的最后，我们再谈谈前端的未来发展及前端职业未来：

    前端会继续分化。例如，喜欢 CSS 图形化的，将更深入地学习 UI 与 CSS 3D 等，进行更炫酷的布局；喜欢 Java 的，将更深入地学习数据的操作，实现更复杂地业务、更有趣的用户体验。
    前端会继续融合。例如，Vue、React、Angular 合并，实现大一统，结束三分天下的局面。
    前端将更加丰富。例如，PC、Mobile、IPad 等的体验更加丰富，不同的平台实现不同的功能。

所以，抓住机遇，不断折腾，创造更好的前端吧！


































C#高级编程第9版：字典使用
C#图解教程 C# 6.0本质论：入门读物
ASP.NET MVC高级编程：mvc入门读物
深入理解C# in Depth：讲的是C#的东西
CLR via C#：讲的是运行时的东西
NET设计规范Framework Design Guideline：讲的是你要如何设计一个类库才能跟.NET浑然一体
《编写高质量代码：改进C#程序的157个建议》、《Effective C#：改进c#程序的50种方法》
测试
其实应该是赵五本的还有.NET Essentials和Pro .NET Performance
Design Pattern:《Gof 设计模式》、《大话设计模式》深入浅出设计模式

我将按照初级，中级，高级三类来划分推荐的书。并且按照格式——名称，语言，内容&评论，推荐指数来写：）。

初级：我认为初级的标准是阐述模式是什么以及常见模式的介绍。 
1. 
名称 ： Head First Design Patterns 
语言 ： java 
评论 ： Jolt大奖得主，介绍了常见的十几种模式。我认为最好的模式入门书籍，内容生动，风格活泼。如果对模式了解较少，看这本书最合适不过，即使你水平不错，相信看了也会有收获。 
推荐 ： 五星
2. 
名称 ：java与模式 
语言 ：java 
评论 : 首先介绍了SRP，LSP等基本原则，然后介绍了GOF23种模式和其他三种模式，以中国传统名著如西游记等举例，写的比较不错。当然1000多页的厚度读起来也需要耐心：）。虽然有些知识稍微过时，而且跟java语言联系太紧密，但还是本好书。 
推荐 ： 四星

名称 ： .NET与设计模式 
语言 ： C# 
评论 ： 和上面一本书定位和风格非常相似，只不过换了语言和平台。如果你是.net的坚决拥护者，无论如何不肯看用 java语言写的书，那么这本书适合你，个人认为这本书写得比C#设计模式要好。 
推荐 ： 四星
4. 
名称 ： C#设计模式 
语言 ： C# 
评论 ： 很薄的一本书，仅仅按照GOF的风格用C#描述了GOF模式，感觉这种书意义不大。 
推荐 ： 两星
5. 
名称 ： 深入浅出设计模式（C#/java版） 
语言 ： C#/java 
评论 ： 和上本书风格相似，语言既有C#又有java，例子感觉是随便从网上搜集的。 
推荐 ： 两星

中级：中级的书不仅仅是介绍模式，更多的是关注模式的应用。 
1. 
名称 ： 设计模式解析 
语言 ： java（第二版） 
评论 ： 也是久负盛名的一本书，代码大全的作者推荐的模式学习书籍。书中的很多思路很有启发性，值得阅读。只是作者狂引建筑的永恒之道，让人觉得莫名其妙。 
推荐 ： 四星
2. 
名称 ： 重构与模式 
语言 ： java 
评论 ： 我期望很高的一本书，但看了以后发现是七分重构三分模式，对模式本身叙述不多，主要将如何重构实现模式，适合有一点基础的朋友阅读。 
推荐 ： 四星
3. 
名称 ： 敏捷软件开发 原则.模式与实践 
语言 ： java，少量C++ 
评论 ： Jolt大奖得主，非常好的一本书，首先讲解了OCP，DIP等基本原则，然后通过几个实际例子讲解模式，论述的十分精彩，我认为是中级图书中最好的一本。 
推荐 ： 五星
4. 
名称 ： 道法自然 
语言 ： C++ 
评论 ： 国人的精彩原创，相信大家早就听说过，看过。通过FishGUI这个实际项目阐述OO和模式。只是不习惯C++的朋友读起来可能有些障碍。 
推荐 ： 五星
5. 
名称 ： 模式的乐趣 
语言 ： java 
评论 ： 很薄的一本小书，通俗易懂，通过三个小例子讲解模式，消遣读物：） 
推荐 ： 三星
6. 
名称 ： 设计模式初学者指南
语言 ： java 
评论 ： 书名严重误导，绝不适合初学者看。作者通过两个项目讲解模式，写的还是不错的。只是作者观点有些偏激，恐怕会引起.net程序员的反感。 
推荐 ： 三星

高级： 相信大家也猜的到，所有模式书籍配得上高级的也只有GOF那本了
名称 ： 设计模式 可复用面向对象软件的基础 
语言 ： C++， 少量Smalltalk 
评论 ： 没什么可说的，大家都清楚：）。除非GOF自己出第二版，否则无法超越。即使没有能力通读也应该买一本作为终极参考 
推荐 ： 五星

